{"/home/travis/build/npmtest/node-npmtest-sinon/test.js":"/* istanbul instrument in package npmtest_sinon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sinon/lib.npmtest_sinon.js":"/* istanbul instrument in package npmtest_sinon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sinon = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sinon = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sinon/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sinon && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sinon */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sinon\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sinon.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_sinon.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sinon.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_sinon.__dirname +\n                    '/lib.npmtest_sinon.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon.js":"\"use strict\";\n\nvar match = require(\"./sinon/match\");\nvar deepEqual = require(\"./sinon/util/core/deep-equal\");\nvar deprecated = require(\"./sinon/util/core/deprecated\");\n\nfunction exposeCoreUtils(target, utils) {\n    var keys = Object.keys(utils);\n\n    keys.forEach(function (key) {\n        var value = utils[key];\n\n        // allow deepEqual to check equality of matchers through dependency injection. Otherwise we get a circular\n        // dependency\n        if (key === \"deepEqual\") {\n            value = deepEqual.use(match);\n        }\n        if (typeof value === \"function\") {\n            value = deprecated.wrap(value, deprecated.defaultMsg(key));\n        }\n        target[key] = value;\n    });\n}\n\nfunction exposeEventTarget(target, eventTarget) {\n    var keys = Object.keys(eventTarget);\n\n    keys.forEach(function (key) {\n        target[key] = deprecated.wrap(eventTarget[key], deprecated.defaultMsg(\"EventTarget\"));\n    });\n}\n\n// Expose internal utilities on `sinon` global for backwards compatibility.\nexposeCoreUtils(exports, require(\"./sinon/util/core/index\"));\n\nexports.assert = require(\"./sinon/assert\");\nexports.collection = require(\"./sinon/collection\");\nexports.match = match;\nexports.spy = require(\"./sinon/spy\");\nexports.spyCall = require(\"./sinon/call\");\nexports.stub = require(\"./sinon/stub\");\nexports.mock = require(\"./sinon/mock\");\nexports.sandbox = require(\"./sinon/sandbox\");\nexports.expectation = require(\"./sinon/mock-expectation\");\nexports.createStubInstance = require(\"./sinon/stub\").createStubInstance;\n\nvar fakeTimers = require(\"./sinon/util/fake_timers\");\nexports.useFakeTimers = fakeTimers.useFakeTimers;\nexports.clock = fakeTimers.clock;\nexports.timers = fakeTimers.timers;\n\nvar event = require(\"./sinon/util/event\");\nexports.Event = deprecated.wrap(event.Event, deprecated.defaultMsg(\"Event\"));\nexports.CustomEvent = deprecated.wrap(event.CustomEvent, deprecated.defaultMsg(\"CustomEvent\"));\nexports.ProgressEvent = deprecated.wrap(event.ProgressEvent, deprecated.defaultMsg(\"ProgressEvent\"));\nexports.EventTarget = {};\nexposeEventTarget(exports.EventTarget, event.EventTarget);\n\nvar fakeXhr = require(\"./sinon/util/fake_xml_http_request\");\nexports.xhr = fakeXhr.xhr;\nexports.FakeXMLHttpRequest = fakeXhr.FakeXMLHttpRequest;\nexports.useFakeXMLHttpRequest = fakeXhr.useFakeXMLHttpRequest;\n\nexports.fakeServer = require(\"./sinon/util/fake_server\");\nexports.fakeServerWithClock = require(\"./sinon/util/fake_server_with_clock\");\n\nvar behavior = require(\"./sinon/behavior\");\n\nexports.addBehavior = function (name, fn) {\n    behavior.addBehavior(exports.stub, name, fn);\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/match.js":"\"use strict\";\n\nvar deepEqual = require(\"./util/core/deep-equal\").use(match); // eslint-disable-line no-use-before-define\nvar every = require(\"./util/core/every\");\nvar functionName = require(\"./util/core/function-name\");\nvar iterableToString = require(\"./util/core/iterable-to-string\");\nvar typeOf = require(\"./util/core/typeOf\");\nvar valueToString = require(\"./util/core/value-to-string\");\n\nvar indexOf = Array.prototype.indexOf;\n\nfunction assertType(value, type, name) {\n    var actual = typeOf(value);\n    if (actual !== type) {\n        throw new TypeError(\"Expected type of \" + name + \" to be \" +\n            type + \", but was \" + actual);\n    }\n}\n\nvar matcher = {\n    toString: function () {\n        return this.message;\n    }\n};\n\nfunction isMatcher(object) {\n    return matcher.isPrototypeOf(object);\n}\n\nfunction matchObject(expectation, actual) {\n    if (actual === null || actual === undefined) {\n        return false;\n    }\n\n    return Object.keys(expectation).every(function (key) {\n        var exp = expectation[key];\n        var act = actual[key];\n\n        if (isMatcher(exp)) {\n            if (!exp.test(act)) {\n                return false;\n            }\n        } else if (typeOf(exp) === \"object\") {\n            if (!matchObject(exp, act)) {\n                return false;\n            }\n        } else if (!deepEqual(exp, act)) {\n            return false;\n        }\n\n        return true;\n    });\n}\n\nvar TYPE_MAP = {\n    \"function\": function (m, expectation, message) {\n        m.test = expectation;\n        m.message = message || \"match(\" + functionName(expectation) + \")\";\n    },\n    number: function (m, expectation) {\n        m.test = function (actual) {\n            // we need type coercion here\n            return expectation == actual; // eslint-disable-line eqeqeq\n        };\n    },\n    object: function (m, expectation) {\n        var array = [];\n\n        if (typeof expectation.test === \"function\") {\n            m.test = function (actual) {\n                return expectation.test(actual) === true;\n            };\n            m.message = \"match(\" + functionName(expectation.test) + \")\";\n            return m;\n        }\n\n        array = Object.keys(expectation).map(function (key) {\n            return key + \": \" + valueToString(expectation[key]);\n        });\n\n        m.test = function (actual) {\n            return matchObject(expectation, actual);\n        };\n        m.message = \"match(\" + array.join(\", \") + \")\";\n\n        return m;\n    },\n    regexp: function (m, expectation) {\n        m.test = function (actual) {\n            return typeof actual === \"string\" && expectation.test(actual);\n        };\n    },\n    string: function (m, expectation) {\n        m.test = function (actual) {\n            return typeof actual === \"string\" && actual.indexOf(expectation) !== -1;\n        };\n        m.message = \"match(\\\"\" + expectation + \"\\\")\";\n    }\n};\n\nfunction match(expectation, message) {\n    var m = Object.create(matcher);\n    var type = typeOf(expectation);\n\n    if (type in TYPE_MAP) {\n        TYPE_MAP[type](m, expectation, message);\n    } else {\n        m.test = function (actual) {\n            return deepEqual(expectation, actual);\n        };\n    }\n\n    if (!m.message) {\n        m.message = \"match(\" + valueToString(expectation) + \")\";\n    }\n\n    return m;\n}\n\nmatcher.or = function (m2) {\n    if (!arguments.length) {\n        throw new TypeError(\"Matcher expected\");\n    } else if (!isMatcher(m2)) {\n        m2 = match(m2);\n    }\n    var m1 = this;\n    var or = Object.create(matcher);\n    or.test = function (actual) {\n        return m1.test(actual) || m2.test(actual);\n    };\n    or.message = m1.message + \".or(\" + m2.message + \")\";\n    return or;\n};\n\nmatcher.and = function (m2) {\n    if (!arguments.length) {\n        throw new TypeError(\"Matcher expected\");\n    } else if (!isMatcher(m2)) {\n        m2 = match(m2);\n    }\n    var m1 = this;\n    var and = Object.create(matcher);\n    and.test = function (actual) {\n        return m1.test(actual) && m2.test(actual);\n    };\n    and.message = m1.message + \".and(\" + m2.message + \")\";\n    return and;\n};\n\nmatch.isMatcher = isMatcher;\n\nmatch.any = match(function () {\n    return true;\n}, \"any\");\n\nmatch.defined = match(function (actual) {\n    return actual !== null && actual !== undefined;\n}, \"defined\");\n\nmatch.truthy = match(function (actual) {\n    return !!actual;\n}, \"truthy\");\n\nmatch.falsy = match(function (actual) {\n    return !actual;\n}, \"falsy\");\n\nmatch.same = function (expectation) {\n    return match(function (actual) {\n        return expectation === actual;\n    }, \"same(\" + valueToString(expectation) + \")\");\n};\n\nmatch.typeOf = function (type) {\n    assertType(type, \"string\", \"type\");\n    return match(function (actual) {\n        return typeOf(actual) === type;\n    }, \"typeOf(\\\"\" + type + \"\\\")\");\n};\n\nmatch.instanceOf = function (type) {\n    assertType(type, \"function\", \"type\");\n    return match(function (actual) {\n        return actual instanceof type;\n    }, \"instanceOf(\" + functionName(type) + \")\");\n};\n\nfunction createPropertyMatcher(propertyTest, messagePrefix) {\n    return function (property, value) {\n        assertType(property, \"string\", \"property\");\n        var onlyProperty = arguments.length === 1;\n        var message = messagePrefix + \"(\\\"\" + property + \"\\\"\";\n        if (!onlyProperty) {\n            message += \", \" + valueToString(value);\n        }\n        message += \")\";\n        return match(function (actual) {\n            if (actual === undefined || actual === null ||\n                    !propertyTest(actual, property)) {\n                return false;\n            }\n            return onlyProperty || deepEqual(value, actual[property]);\n        }, message);\n    };\n}\n\nmatch.has = createPropertyMatcher(function (actual, property) {\n    if (typeof actual === \"object\") {\n        return property in actual;\n    }\n    return actual[property] !== undefined;\n}, \"has\");\n\nmatch.hasOwn = createPropertyMatcher(function (actual, property) {\n    return actual.hasOwnProperty(property);\n}, \"hasOwn\");\n\nmatch.array = match.typeOf(\"array\");\n\nmatch.array.deepEquals = function (expectation) {\n    return match(function (actual) {\n        // Comparing lengths is the fastest way to spot a difference before iterating through every item\n        var sameLength = actual.length === expectation.length;\n        return typeOf(actual) === \"array\" && sameLength && every(actual, function (element, index) {\n            return expectation[index] === element;\n        });\n    }, \"deepEquals([\" + iterableToString(expectation) + \"])\");\n};\n\nmatch.array.startsWith = function (expectation) {\n    return match(function (actual) {\n        return typeOf(actual) === \"array\" && every(expectation, function (expectedElement, index) {\n            return actual[index] === expectedElement;\n        });\n    }, \"startsWith([\" + iterableToString(expectation) + \"])\");\n};\n\nmatch.array.endsWith = function (expectation) {\n    return match(function (actual) {\n        // This indicates the index in which we should start matching\n        var offset = actual.length - expectation.length;\n\n        return typeOf(actual) === \"array\" && every(expectation, function (expectedElement, index) {\n            return actual[offset + index] === expectedElement;\n        });\n    }, \"endsWith([\" + iterableToString(expectation) + \"])\");\n};\n\nmatch.array.contains = function (expectation) {\n    return match(function (actual) {\n        return typeOf(actual) === \"array\" && every(expectation, function (expectedElement) {\n            return indexOf.call(actual, expectedElement) !== -1;\n        });\n    }, \"contains([\" + iterableToString(expectation) + \"])\");\n};\n\nmatch.map = match.typeOf(\"map\");\n\nmatch.map.deepEquals = function mapDeepEquals(expectation) {\n    return match(function (actual) {\n        // Comparing lengths is the fastest way to spot a difference before iterating through every item\n        var sameLength = actual.size === expectation.size;\n        return typeOf(actual) === \"map\" && sameLength && every(actual, function (element, key) {\n            return expectation.has(key) && expectation.get(key) === element;\n        });\n    }, \"deepEquals(Map[\" + iterableToString(expectation) + \"])\");\n};\n\nmatch.map.contains = function mapContains(expectation) {\n    return match(function (actual) {\n        return typeOf(actual) === \"map\" && every(expectation, function (element, key) {\n            return actual.has(key) && actual.get(key) === element;\n        });\n    }, \"contains(Map[\" + iterableToString(expectation) + \"])\");\n};\n\nmatch.set = match.typeOf(\"set\");\n\nmatch.set.deepEquals = function setDeepEquals(expectation) {\n    return match(function (actual) {\n        // Comparing lengths is the fastest way to spot a difference before iterating through every item\n        var sameLength = actual.size === expectation.size;\n        return typeOf(actual) === \"set\" && sameLength && every(actual, function (element) {\n            return expectation.has(element);\n        });\n    }, \"deepEquals(Set[\" + iterableToString(expectation) + \"])\");\n};\n\nmatch.set.contains = function setContains(expectation) {\n    return match(function (actual) {\n        return typeOf(actual) === \"set\" && every(expectation, function (element) {\n            return actual.has(element);\n        });\n    }, \"contains(Set[\" + iterableToString(expectation) + \"])\");\n};\n\nmatch.bool = match.typeOf(\"boolean\");\nmatch.number = match.typeOf(\"number\");\nmatch.string = match.typeOf(\"string\");\nmatch.object = match.typeOf(\"object\");\nmatch.func = match.typeOf(\"function\");\nmatch.regexp = match.typeOf(\"regexp\");\nmatch.date = match.typeOf(\"date\");\nmatch.symbol = match.typeOf(\"symbol\");\n\nmodule.exports = match;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/deep-equal.js":"\"use strict\";\n\nvar div = typeof document !== \"undefined\" && document.createElement(\"div\");\n\nfunction isReallyNaN(val) {\n    return val !== val;\n}\n\nfunction isDOMNode(obj) {\n    var success = false;\n\n    try {\n        obj.appendChild(div);\n        success = div.parentNode === obj;\n    } catch (e) {\n        return false;\n    } finally {\n        try {\n            obj.removeChild(div);\n        } catch (e) {\n            // Remove failed, not much we can do about that\n        }\n    }\n\n    return success;\n}\n\nfunction isElement(obj) {\n    return div && obj && obj.nodeType === 1 && isDOMNode(obj);\n}\n\nvar deepEqual = module.exports = function deepEqual(a, b) {\n    if (typeof a !== \"object\" || typeof b !== \"object\") {\n        return isReallyNaN(a) && isReallyNaN(b) || a === b;\n    }\n\n    if (isElement(a) || isElement(b)) {\n        return a === b;\n    }\n\n    if (a === b) {\n        return true;\n    }\n\n    if ((a === null && b !== null) || (a !== null && b === null)) {\n        return false;\n    }\n\n    if (a instanceof RegExp && b instanceof RegExp) {\n        return (a.source === b.source) && (a.global === b.global) &&\n            (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);\n    }\n\n    if (a instanceof Error && b instanceof Error) {\n        return a === b;\n    }\n\n    var aString = Object.prototype.toString.call(a);\n    if (aString !== Object.prototype.toString.call(b)) {\n        return false;\n    }\n\n    if (aString === \"[object Date]\") {\n        return a.valueOf() === b.valueOf();\n    }\n\n    var prop;\n    var aLength = 0;\n    var bLength = 0;\n\n    if (aString === \"[object Array]\" && a.length !== b.length) {\n        return false;\n    }\n\n    for (prop in a) {\n        if (Object.prototype.hasOwnProperty.call(a, prop)) {\n            aLength += 1;\n\n            if (!(prop in b)) {\n                return false;\n            }\n\n            // allow alternative function for recursion\n            if (!(arguments[2] || deepEqual)(a[prop], b[prop])) {\n                return false;\n            }\n        }\n    }\n\n    for (prop in b) {\n        if (Object.prototype.hasOwnProperty.call(b, prop)) {\n            bLength += 1;\n        }\n    }\n\n    return aLength === bLength;\n};\n\ndeepEqual.use = function (match) {\n    return function deepEqual$matcher(a, b) {\n        // If both are matchers they must be the same instance in order to be considered equal\n        // If we didn't do that we would end up running one matcher against the other\n        if (match.isMatcher(a)) {\n            if (match.isMatcher(b)) {\n                return a === b;\n            }\n\n            return a.test(b);\n        }\n\n        return deepEqual(a, b, deepEqual$matcher);\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/every.js":"\"use strict\";\n\n// This is an `every` implementation that works for all iterables\nmodule.exports = function every(obj, fn) {\n    var pass = true;\n\n    try {\n        obj.forEach(function () {\n            if (!fn.apply(this, arguments)) {\n                // Throwing an error is the only way to break `forEach`\n                throw new Error();\n            }\n        });\n    } catch (e) {\n        pass = false;\n    }\n\n    return pass;\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/function-name.js":"\"use strict\";\n\nmodule.exports = function functionName(func) {\n    var name = func.displayName || func.name;\n    var matches;\n\n    // Use function decomposition as a last resort to get function\n    // name. Does not rely on function decomposition to work - if it\n    // doesn't debugging will be slightly less informative\n    // (i.e. toString will say 'spy' rather than 'myFunc').\n    if (!name && (matches = func.toString().match(/function ([^\\s\\(]+)/))) {\n        name = matches[1];\n    }\n\n    return name;\n};\n\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/iterable-to-string.js":"\"use strict\";\nvar typeOf = require(\"./typeOf\");\n\nmodule.exports = function iterableToString(obj) {\n    var representation = \"\";\n\n    function stringify(item) {\n        return typeof item === \"string\" ? \"'\" + item + \"'\" : String(item);\n    }\n\n    function mapToString(map) {\n        map.forEach(function (value, key) {\n            representation += \"[\" + stringify(key) + \",\" + stringify(value) + \"],\";\n        });\n\n        representation = representation.slice(0, -1);\n        return representation;\n    }\n\n    function genericIterableToString(iterable) {\n        iterable.forEach(function (value) {\n            representation += stringify(value) + \",\";\n        });\n\n        representation = representation.slice(0, -1);\n        return representation;\n    }\n\n    if (typeOf(obj) === \"map\") {\n        return mapToString(obj);\n    }\n\n    return genericIterableToString(obj);\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/typeOf.js":"\"use strict\";\n\nvar type = require(\"type-detect\");\n\nmodule.exports = function typeOf(value) {\n    return type(value).toLowerCase();\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/value-to-string.js":"\"use strict\";\n\nmodule.exports = function (value) {\n    if (value && value.toString) {\n        return value.toString();\n    }\n    return String(value);\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/deprecated.js":"/*eslint no-console: 0 */\n\"use strict\";\n\n// wrap returns a function that will invoke the supplied function and print a deprecation warning to the console each\n// time it is called.\nexports.wrap = function (func, msg) {\n    var wrapped = function () {\n        exports.printWarning(msg);\n        return func.apply(this, arguments);\n    };\n    if (func.prototype) {\n        wrapped.prototype = func.prototype;\n    }\n    return wrapped;\n};\n\n// defaultMsg returns a string which can be supplied to `wrap()` to notify the user that a particular part of the\n// sinon API has been deprecated.\nexports.defaultMsg = function (funcName) {\n    return \"sinon.\" + funcName + \" is deprecated and will be removed from the public API in a future version of sinon.\";\n};\n\nexports.printWarning = function (msg) {\n    // Watch out for IE7 and below! :(\n    if (typeof console !== \"undefined\") {\n        if (console.info) {\n            console.info(msg);\n        } else {\n            console.log(msg);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/index.js":"\"use strict\";\n\nmodule.exports = {\n    calledInOrder: require(\"./called-in-order\"),\n    configureLogError: require(\"./log_error\"),\n    defaultConfig: require(\"./default-config\"),\n    deepEqual: require(\"./deep-equal\"),\n    every: require(\"./every\"),\n    extend: require(\"./extend\"),\n    format: require(\"./format\"),\n    functionName: require(\"./function-name\"),\n    functionToString: require(\"./function-to-string\"),\n    getConfig: require(\"./get-config\"),\n    getPropertyDescriptor: require(\"./get-property-descriptor\"),\n    iterableToString: require(\"./iterable-to-string\"),\n    orderByFirstCall: require(\"./order-by-first-call\"),\n    restore: require(\"./restore\"),\n    timesInWords: require(\"./times-in-words\"),\n    typeOf: require(\"./typeOf\"),\n    walk: require(\"./walk\"),\n    wrapMethod: require(\"./wrap-method\")\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/called-in-order.js":"\"use strict\";\n\nmodule.exports = function calledInOrder(spies) {\n    if (arguments.length > 1) {\n        spies = arguments;\n    }\n\n    for (var i = 1, l = spies.length; i < l; i++) {\n        if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {\n            return false;\n        }\n    }\n\n    return true;\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/log_error.js":"\"use strict\";\n\n// cache a reference to setTimeout, so that our reference won't be stubbed out\n// when using fake timers and errors will still get logged\n// https://github.com/cjohansen/Sinon.JS/issues/381\nvar realSetTimeout = setTimeout;\n\nfunction configure(config) {\n    config = config || {};\n    // Function which prints errors.\n    if (!config.hasOwnProperty(\"logger\")) {\n        config.logger = function () { };\n    }\n    // When set to true, any errors logged will be thrown immediately;\n    // If set to false, the errors will be thrown in separate execution frame.\n    if (!config.hasOwnProperty(\"useImmediateExceptions\")) {\n        config.useImmediateExceptions = true;\n    }\n    // wrap realSetTimeout with something we can stub in tests\n    if (!config.hasOwnProperty(\"setTimeout\")) {\n        config.setTimeout = realSetTimeout;\n    }\n\n    return function logError(label, e) {\n        var msg = label + \" threw exception: \";\n        var err = { name: e.name || label, message: e.message || e.toString(), stack: e.stack };\n\n        function throwLoggedError() {\n            err.message = msg + err.message;\n            throw err;\n        }\n\n        config.logger(msg + \"[\" + err.name + \"] \" + err.message);\n\n        if (err.stack) {\n            config.logger(err.stack);\n        }\n\n        if (config.useImmediateExceptions) {\n            throwLoggedError();\n        } else {\n            config.setTimeout(throwLoggedError, 0);\n        }\n    };\n}\n\nmodule.exports = configure;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/default-config.js":"\"use strict\";\n\nmodule.exports = {\n    injectIntoThis: true,\n    injectInto: null,\n    properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n    useFakeTimers: true,\n    useFakeServer: true\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/extend.js":"\"use strict\";\n\n// Adapted from https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\nvar hasDontEnumBug = (function () {\n    var obj = {\n        constructor: function () {\n            return \"0\";\n        },\n        toString: function () {\n            return \"1\";\n        },\n        valueOf: function () {\n            return \"2\";\n        },\n        toLocaleString: function () {\n            return \"3\";\n        },\n        prototype: function () {\n            return \"4\";\n        },\n        isPrototypeOf: function () {\n            return \"5\";\n        },\n        propertyIsEnumerable: function () {\n            return \"6\";\n        },\n        hasOwnProperty: function () {\n            return \"7\";\n        },\n        length: function () {\n            return \"8\";\n        },\n        unique: function () {\n            return \"9\";\n        }\n    };\n\n    var result = [];\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            result.push(obj[prop]());\n        }\n    }\n    return result.join(\"\") !== \"0123456789\";\n})();\n\n/* Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will\n *         override properties in previous sources.\n *\n * target - The Object to extend\n * sources - Objects to copy properties from.\n *\n * Returns the extended target\n */\nmodule.exports = function extend(target /*, sources */) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    var source, i, prop;\n\n    for (i = 0; i < sources.length; i++) {\n        source = sources[i];\n\n        for (prop in source) {\n            if (source.hasOwnProperty(prop)) {\n                target[prop] = source[prop];\n            }\n        }\n\n        // Make sure we copy (own) toString method even when in JScript with DontEnum bug\n        // See https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\n        if (hasDontEnumBug && source.hasOwnProperty(\"toString\") && source.toString !== target.toString) {\n            target.toString = source.toString;\n        }\n    }\n\n    return target;\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/format.js":"\"use strict\";\n\nvar formatio = require(\"formatio\");\n\nvar formatter = formatio.configure({\n    quoteStrings: false,\n    limitChildrenCount: 250\n});\n\nmodule.exports = function format() {\n    return formatter.ascii.apply(formatter, arguments);\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/function-to-string.js":"\"use strict\";\n\nmodule.exports = function toString() {\n    var i, prop, thisValue;\n    if (this.getCall && this.callCount) {\n        i = this.callCount;\n\n        while (i--) {\n            thisValue = this.getCall(i).thisValue;\n\n            for (prop in thisValue) {\n                if (thisValue[prop] === this) {\n                    return prop;\n                }\n            }\n        }\n    }\n\n    return this.displayName || \"sinon fake\";\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/get-config.js":"\"use strict\";\n\nvar defaultConfig = require(\"./default-config\");\n\nmodule.exports = function getConfig(custom) {\n    var config = {};\n    var prop;\n\n    custom = custom || {};\n\n    for (prop in defaultConfig) {\n        if (defaultConfig.hasOwnProperty(prop)) {\n            config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaultConfig[prop];\n        }\n    }\n\n    return config;\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/get-property-descriptor.js":"\"use strict\";\n\nmodule.exports = function getPropertyDescriptor(object, property) {\n    var proto = object;\n    var descriptor;\n\n    while (proto && !(descriptor = Object.getOwnPropertyDescriptor(proto, property))) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return descriptor;\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/order-by-first-call.js":"\"use strict\";\n\nmodule.exports = function orderByFirstCall(spies) {\n    return spies.sort(function (a, b) {\n        // uuid, won't ever be equal\n        var aCall = a.getCall(0);\n        var bCall = b.getCall(0);\n        var aId = aCall && aCall.callId || -1;\n        var bId = bCall && bCall.callId || -1;\n\n        return aId < bId ? -1 : 1;\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/restore.js":"\"use strict\";\n\nvar walk = require(\"./walk\");\n\nfunction isRestorable(obj) {\n    return typeof obj === \"function\" && typeof obj.restore === \"function\" && obj.restore.sinon;\n}\n\nmodule.exports = function restore(object) {\n    if (object !== null && typeof object === \"object\") {\n        walk(object, function (prop) {\n            if (isRestorable(object[prop])) {\n                object[prop].restore();\n            }\n        });\n    } else if (isRestorable(object)) {\n        object.restore();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/walk.js":"\"use strict\";\n\nfunction walkInternal(obj, iterator, context, originalObj, seen) {\n    var proto, prop;\n\n    if (typeof Object.getOwnPropertyNames !== \"function\") {\n        // We explicitly want to enumerate through all of the prototype's properties\n        // in this case, therefore we deliberately leave out an own property check.\n        /* eslint-disable guard-for-in */\n        for (prop in obj) {\n            iterator.call(context, obj[prop], prop, obj);\n        }\n        /* eslint-enable guard-for-in */\n\n        return;\n    }\n\n    Object.getOwnPropertyNames(obj).forEach(function (k) {\n        if (seen[k] !== true) {\n            seen[k] = true;\n            var target = typeof Object.getOwnPropertyDescriptor(obj, k).get === \"function\" ?\n                originalObj : obj;\n            iterator.call(context, k, target);\n        }\n    });\n\n    proto = Object.getPrototypeOf(obj);\n    if (proto) {\n        walkInternal(proto, iterator, context, originalObj, seen);\n    }\n}\n\n/* Walks the prototype chain of an object and iterates over every own property\n * name encountered. The iterator is called in the same fashion that Array.prototype.forEach\n * works, where it is passed the value, key, and own object as the 1st, 2nd, and 3rd positional\n * argument, respectively. In cases where Object.getOwnPropertyNames is not available, walk will\n * default to using a simple for..in loop.\n *\n * obj - The object to walk the prototype chain for.\n * iterator - The function to be called on each pass of the walk.\n * context - (Optional) When given, the iterator will be called with this object as the receiver.\n */\nmodule.exports = function walk(obj, iterator, context) {\n    return walkInternal(obj, iterator, context, obj, {});\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/times-in-words.js":"\"use strict\";\n\nvar array = [null, \"once\", \"twice\", \"thrice\"];\n\nmodule.exports = function timesInWords(count) {\n    return array[count] || (count || 0) + \" times\";\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/core/wrap-method.js":"\"use strict\";\n\nvar getPropertyDescriptor = require(\"./get-property-descriptor\");\nvar valueToString = require(\"./value-to-string\");\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isFunction(obj) {\n    return typeof obj === \"function\" || !!(obj && obj.constructor && obj.call && obj.apply);\n}\n\nfunction mirrorProperties(target, source) {\n    for (var prop in source) {\n        if (!hasOwn.call(target, prop)) {\n            target[prop] = source[prop];\n        }\n    }\n}\n\n// Cheap way to detect if we have ES5 support.\nvar hasES5Support = \"keys\" in Object;\n\nmodule.exports = function wrapMethod(object, property, method) {\n    if (!object) {\n        throw new TypeError(\"Should wrap property of object\");\n    }\n\n    if (typeof method !== \"function\" && typeof method !== \"object\") {\n        throw new TypeError(\"Method wrapper should be a function or a property descriptor\");\n    }\n\n    function checkWrappedMethod(wrappedMethod) {\n        var error;\n\n        if (!isFunction(wrappedMethod)) {\n            error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                valueToString(property) + \" as function\");\n        } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n            error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already wrapped\");\n        } else if (wrappedMethod.calledBefore) {\n            var verb = wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n            error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already \" + verb);\n        }\n\n        if (error) {\n            if (wrappedMethod && wrappedMethod.stackTrace) {\n                error.stack += \"\\n--------------\\n\" + wrappedMethod.stackTrace;\n            }\n            throw error;\n        }\n    }\n\n    var error, wrappedMethod, i;\n\n    function simplePropertyAssignment() {\n        wrappedMethod = object[property];\n        checkWrappedMethod(wrappedMethod);\n        object[property] = method;\n        method.displayName = property;\n    }\n\n    // Firefox has a problem when using hasOwn.call on objects from other frames.\n    var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);\n\n    if (hasES5Support) {\n        var methodDesc = (typeof method === \"function\") ? {value: method} : method;\n        var wrappedMethodDesc = getPropertyDescriptor(object, property);\n\n        if (!wrappedMethodDesc) {\n            error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                property + \" as function\");\n        } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {\n            error = new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n        }\n        if (error) {\n            if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {\n                error.stack += \"\\n--------------\\n\" + wrappedMethodDesc.stackTrace;\n            }\n            throw error;\n        }\n\n        var types = Object.keys(methodDesc);\n        for (i = 0; i < types.length; i++) {\n            wrappedMethod = wrappedMethodDesc[types[i]];\n            checkWrappedMethod(wrappedMethod);\n        }\n\n        mirrorProperties(methodDesc, wrappedMethodDesc);\n        for (i = 0; i < types.length; i++) {\n            mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n        }\n        Object.defineProperty(object, property, methodDesc);\n\n        // catch failing assignment\n        // this is the converse of the check in `.restore` below\n        if ( typeof method === \"function\" && object[property] !== method ) {\n            // correct any wrongdoings caused by the defineProperty call above,\n            // such as adding new items (if object was a Storage object)\n            delete object[property];\n            simplePropertyAssignment();\n        }\n    } else {\n        simplePropertyAssignment();\n    }\n\n    method.displayName = property;\n\n    // Set up a stack trace which can be used later to find what line of\n    // code the original method was created on.\n    method.stackTrace = (new Error(\"Stack Trace for original\")).stack;\n\n    method.restore = function () {\n        // For prototype properties try to reset by delete first.\n        // If this fails (ex: localStorage on mobile safari) then force a reset\n        // via direct assignment.\n        if (!owned) {\n            // In some cases `delete` may throw an error\n            try {\n                delete object[property];\n            } catch (e) {} // eslint-disable-line no-empty\n            // For native code functions `delete` fails without throwing an error\n            // on Chrome < 43, PhantomJS, etc.\n        } else if (hasES5Support) {\n            Object.defineProperty(object, property, wrappedMethodDesc);\n        }\n\n        if (hasES5Support) {\n            var descriptor = getPropertyDescriptor(object, property);\n            if (descriptor && descriptor.value === method) {\n                object[property] = wrappedMethod;\n            }\n        }\n        else {\n        // Use strict equality comparison to check failures then force a reset\n        // via direct assignment.\n            if (object[property] === method) {\n                object[property] = wrappedMethod;\n            }\n        }\n    };\n\n    method.wrappedMethod = wrappedMethod;\n\n    method.restore.sinon = true;\n\n    if (!hasES5Support) {\n        mirrorProperties(method, wrappedMethod);\n    }\n\n    return method;\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/assert.js":"\"use strict\";\n\nvar calledInOrder = require(\"./util/core/called-in-order\");\nvar orderByFirstCall = require(\"./util/core/order-by-first-call\");\nvar timesInWords = require(\"./util/core/times-in-words\");\nvar format = require(\"./util/core/format\");\nvar sinonMatch = require(\"./match\");\n\nvar slice = Array.prototype.slice;\n\nvar assert;\n\nfunction verifyIsStub() {\n    var args = Array.prototype.slice.call(arguments);\n\n    args.forEach(function (method) {\n        if (!method) {\n            assert.fail(\"fake is not a spy\");\n        }\n\n        if (method.proxy && method.proxy.isSinonProxy) {\n            verifyIsStub(method.proxy);\n        } else {\n            if (typeof method !== \"function\") {\n                assert.fail(method + \" is not a function\");\n            }\n\n            if (typeof method.getCall !== \"function\") {\n                assert.fail(method + \" is not stubbed\");\n            }\n        }\n    });\n}\n\nfunction verifyIsValidAssertion(assertionMethod, assertionArgs) {\n    switch (assertionMethod) {\n        case \"notCalled\":\n        case \"called\":\n        case \"calledOnce\":\n        case \"calledTwice\":\n        case \"calledThrice\":\n            if (assertionArgs.length !== 0) {\n                assert.fail(assertionMethod +\n                            \" takes 1 argument but was called with \" + (assertionArgs.length + 1) + \" arguments\");\n            }\n            break;\n        default:\n            break;\n    }\n}\n\nfunction failAssertion(object, msg) {\n    object = object || global;\n    var failMethod = object.fail || assert.fail;\n    failMethod.call(object, msg);\n}\n\nfunction mirrorPropAsAssertion(name, method, message) {\n    if (arguments.length === 2) {\n        message = method;\n        method = name;\n    }\n\n    assert[name] = function (fake) {\n        verifyIsStub(fake);\n\n        var args = slice.call(arguments, 1);\n        var failed = false;\n\n        verifyIsValidAssertion(name, args);\n\n        if (typeof method === \"function\") {\n            failed = !method(fake);\n        } else {\n            failed = typeof fake[method] === \"function\" ?\n                !fake[method].apply(fake, args) : !fake[method];\n        }\n\n        if (failed) {\n            failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));\n        } else {\n            assert.pass(name);\n        }\n    };\n}\n\nfunction exposedName(prefix, prop) {\n    return !prefix || /^fail/.test(prop) ? prop :\n        prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);\n}\n\nassert = {\n    failException: \"AssertError\",\n\n    fail: function fail(message) {\n        var error = new Error(message);\n        error.name = this.failException || assert.failException;\n\n        throw error;\n    },\n\n    pass: function pass() {},\n\n    callOrder: function assertCallOrder() {\n        verifyIsStub.apply(null, arguments);\n        var expected = \"\";\n        var actual = \"\";\n\n        if (!calledInOrder(arguments)) {\n            try {\n                expected = [].join.call(arguments, \", \");\n                var calls = slice.call(arguments);\n                var i = calls.length;\n                while (i) {\n                    if (!calls[--i].called) {\n                        calls.splice(i, 1);\n                    }\n                }\n                actual = orderByFirstCall(calls).join(\", \");\n            } catch (e) {\n                // If this fails, we'll just fall back to the blank string\n            }\n\n            failAssertion(this, \"expected \" + expected + \" to be \" +\n                        \"called in order but were called as \" + actual);\n        } else {\n            assert.pass(\"callOrder\");\n        }\n    },\n\n    callCount: function assertCallCount(method, count) {\n        verifyIsStub(method);\n\n        if (method.callCount !== count) {\n            var msg = \"expected %n to be called \" + timesInWords(count) +\n                \" but was called %c%C\";\n            failAssertion(this, method.printf(msg));\n        } else {\n            assert.pass(\"callCount\");\n        }\n    },\n\n    expose: function expose(target, options) {\n        if (!target) {\n            throw new TypeError(\"target is null or undefined\");\n        }\n\n        var o = options || {};\n        var prefix = typeof o.prefix === \"undefined\" && \"assert\" || o.prefix;\n        var includeFail = typeof o.includeFail === \"undefined\" || !!o.includeFail;\n        var instance = this;\n\n        Object.keys(instance).forEach(function (method) {\n            if (method !== \"expose\" && (includeFail || !/^(fail)/.test(method))) {\n                target[exposedName(prefix, method)] = instance[method];\n            }\n        });\n\n        return target;\n    },\n\n    match: function match(actual, expectation) {\n        var matcher = sinonMatch(expectation);\n        if (matcher.test(actual)) {\n            assert.pass(\"match\");\n        } else {\n            var formatted = [\n                \"expected value to match\",\n                \"    expected = \" + format(expectation),\n                \"    actual = \" + format(actual)\n            ];\n\n            failAssertion(this, formatted.join(\"\\n\"));\n        }\n    }\n};\n\nmirrorPropAsAssertion(\"called\", \"expected %n to have been called at least once but was never called\");\nmirrorPropAsAssertion(\"notCalled\", function (spy) {\n    return !spy.called;\n}, \"expected %n to not have been called but was called %c%C\");\nmirrorPropAsAssertion(\"calledOnce\", \"expected %n to be called once but was called %c%C\");\nmirrorPropAsAssertion(\"calledTwice\", \"expected %n to be called twice but was called %c%C\");\nmirrorPropAsAssertion(\"calledThrice\", \"expected %n to be called thrice but was called %c%C\");\nmirrorPropAsAssertion(\"calledOn\", \"expected %n to be called with %1 as this but was called with %t\");\nmirrorPropAsAssertion(\n    \"alwaysCalledOn\",\n    \"expected %n to always be called with %1 as this but was called with %t\"\n);\nmirrorPropAsAssertion(\"calledWithNew\", \"expected %n to be called with new\");\nmirrorPropAsAssertion(\"alwaysCalledWithNew\", \"expected %n to always be called with new\");\nmirrorPropAsAssertion(\"calledWith\", \"expected %n to be called with arguments %D\");\nmirrorPropAsAssertion(\"calledWithMatch\", \"expected %n to be called with match %D\");\nmirrorPropAsAssertion(\"alwaysCalledWith\", \"expected %n to always be called with arguments %D\");\nmirrorPropAsAssertion(\"alwaysCalledWithMatch\", \"expected %n to always be called with match %D\");\nmirrorPropAsAssertion(\"calledWithExactly\", \"expected %n to be called with exact arguments %D\");\nmirrorPropAsAssertion(\"alwaysCalledWithExactly\", \"expected %n to always be called with exact arguments %D\");\nmirrorPropAsAssertion(\"neverCalledWith\", \"expected %n to never be called with arguments %*%C\");\nmirrorPropAsAssertion(\"neverCalledWithMatch\", \"expected %n to never be called with match %*%C\");\nmirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\nmirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\n\nmodule.exports = assert;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/collection.js":"\"use strict\";\n\nvar sinonSpy = require(\"./spy\");\nvar sinonStub = require(\"./stub\");\nvar sinonMock = require(\"./mock\");\nvar throwOnFalsyObject = require(\"./throw-on-falsy-object\");\nvar collectOwnMethods = require(\"./collect-own-methods\");\nvar stubNonFunctionProperty = require(\"./stub-non-function-property\");\n\nvar push = [].push;\n\nfunction getFakes(fakeCollection) {\n    if (!fakeCollection.fakes) {\n        fakeCollection.fakes = [];\n    }\n\n    return fakeCollection.fakes;\n}\n\nfunction each(fakeCollection, method) {\n    var fakes = getFakes(fakeCollection);\n    var matchingFakes = fakes.filter(function (fake) {\n        return typeof fake[method] === \"function\";\n    });\n\n    matchingFakes.forEach(function (fake) {\n        fake[method]();\n    });\n}\n\nvar collection = {\n    verify: function verify() {\n        each(this, \"verify\");\n    },\n\n    restore: function restore() {\n        each(this, \"restore\");\n        this.fakes = [];\n    },\n\n    reset: function reset() {\n        each(this, \"reset\");\n    },\n\n    resetBehavior: function resetBehavior() {\n        each(this, \"resetBehavior\");\n    },\n\n    resetHistory: function resetHistory() {\n        each(this, \"resetHistory\");\n    },\n\n    verifyAndRestore: function verifyAndRestore() {\n        var exception;\n\n        try {\n            this.verify();\n        } catch (e) {\n            exception = e;\n        }\n\n        this.restore();\n\n        if (exception) {\n            throw exception;\n        }\n    },\n\n    add: function add(fake) {\n        push.call(getFakes(this), fake);\n        return fake;\n    },\n\n    spy: function spy() {\n        return this.add(sinonSpy.apply(sinonSpy, arguments));\n    },\n\n    stub: function stub(object, property/*, value*/) {\n        throwOnFalsyObject.apply(null, arguments);\n\n        var isStubbingEntireObject = typeof property === \"undefined\" && typeof object === \"object\";\n        var isStubbingNonFunctionProperty = property && typeof object[property] !== \"function\";\n        var stubbed = isStubbingNonFunctionProperty ?\n                        stubNonFunctionProperty.apply(null, arguments) :\n                        sinonStub.apply(null, arguments);\n\n        if (isStubbingEntireObject) {\n            collectOwnMethods(stubbed).forEach(this.add.bind(this));\n        } else {\n            this.add(stubbed);\n        }\n\n        return stubbed;\n    },\n\n    mock: function mock() {\n        return this.add(sinonMock.apply(null, arguments));\n    },\n\n    inject: function inject(obj) {\n        var col = this;\n\n        obj.spy = function () {\n            return col.spy.apply(col, arguments);\n        };\n\n        obj.stub = function () {\n            return col.stub.apply(col, arguments);\n        };\n\n        obj.mock = function () {\n            return col.mock.apply(col, arguments);\n        };\n\n        return obj;\n    }\n};\n\nmodule.exports = collection;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/spy.js":"\"use strict\";\n\nvar extend = require(\"./util/core/extend\");\nvar functionName = require(\"./util/core/function-name\");\nvar functionToString = require(\"./util/core/function-to-string\");\nvar getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\nvar sinonMatch = require(\"./match\");\nvar deepEqual = require(\"./util/core/deep-equal\").use(sinonMatch);\nvar spyCall = require(\"./call\");\nvar wrapMethod = require(\"./util/core/wrap-method\");\nvar sinonFormat = require(\"./util/core/format\");\nvar valueToString = require(\"./util/core/value-to-string\");\n\nvar push = Array.prototype.push;\nvar slice = Array.prototype.slice;\nvar callId = 0;\nvar ErrorConstructor = Error.prototype.constructor;\n\nfunction spy(object, property, types) {\n    var descriptor, methodDesc;\n\n    if (!property && typeof object === \"function\") {\n        return spy.create(object);\n    }\n\n    if (!object && !property) {\n        return spy.create(function () { });\n    }\n\n    if (!types) {\n        return wrapMethod(object, property, spy.create(object[property]));\n    }\n\n    descriptor = {};\n    methodDesc = getPropertyDescriptor(object, property);\n\n    types.forEach(function (type) {\n        descriptor[type] = spy.create(methodDesc[type]);\n    });\n\n    return wrapMethod(object, property, descriptor);\n}\n\nfunction matchingFake(fakes, args, strict) {\n    if (!fakes) {\n        return undefined;\n    }\n\n    var matchingFakes = fakes.filter(function (fake) {\n        return fake.matches(args, strict);\n    });\n\n    return matchingFakes.pop();\n}\n\nfunction incrementCallCount() {\n    this.called = true;\n    this.callCount += 1;\n    this.notCalled = false;\n    this.calledOnce = this.callCount === 1;\n    this.calledTwice = this.callCount === 2;\n    this.calledThrice = this.callCount === 3;\n}\n\nfunction createCallProperties() {\n    this.firstCall = this.getCall(0);\n    this.secondCall = this.getCall(1);\n    this.thirdCall = this.getCall(2);\n    this.lastCall = this.getCall(this.callCount - 1);\n}\n\nfunction createProxy(func, proxyLength) {\n    // Retain the function length:\n    var p;\n    if (proxyLength) {\n        // Do not change this to use an eval. Projects that depend on sinon block the use of eval.\n        // ref: https://github.com/sinonjs/sinon/issues/710\n        switch (proxyLength) {\n            /*eslint-disable no-unused-vars, max-len*/\n            case 1: p = function proxy(a) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 2: p = function proxy(a, b) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 3: p = function proxy(a, b, c) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 4: p = function proxy(a, b, c, d) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 5: p = function proxy(a, b, c, d, e) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 6: p = function proxy(a, b, c, d, e, f) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 7: p = function proxy(a, b, c, d, e, f, g) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 8: p = function proxy(a, b, c, d, e, f, g, h) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 9: p = function proxy(a, b, c, d, e, f, g, h, i) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 10: p = function proxy(a, b, c, d, e, f, g, h, i, j) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 11: p = function proxy(a, b, c, d, e, f, g, h, i, j, k) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            case 12: p = function proxy(a, b, c, d, e, f, g, h, i, j, k, l) { return p.invoke(func, this, slice.call(arguments)); }; break;\n            default: p = function proxy() { return p.invoke(func, this, slice.call(arguments)); }; break;\n            /*eslint-enable*/\n        }\n    } else {\n        p = function proxy() {\n            return p.invoke(func, this, slice.call(arguments));\n        };\n    }\n    p.isSinonProxy = true;\n    return p;\n}\n\nvar uuid = 0;\n\n// Public API\nvar spyApi = {\n    formatters: require(\"./spy-formatters\"),\n\n    reset: function () {\n        if (this.invoking) {\n            var err = new Error(\"Cannot reset Sinon function while invoking it. \" +\n                                \"Move the call to .reset outside of the callback.\");\n            err.name = \"InvalidResetException\";\n            throw err;\n        }\n\n        this.called = false;\n        this.notCalled = true;\n        this.calledOnce = false;\n        this.calledTwice = false;\n        this.calledThrice = false;\n        this.callCount = 0;\n        this.firstCall = null;\n        this.secondCall = null;\n        this.thirdCall = null;\n        this.lastCall = null;\n        this.args = [];\n        this.returnValues = [];\n        this.thisValues = [];\n        this.exceptions = [];\n        this.callIds = [];\n        this.errorsWithCallStack = [];\n        if (this.fakes) {\n            this.fakes.forEach(function (fake) {\n                fake.reset();\n            });\n        }\n\n        return this;\n    },\n\n    create: function create(func, spyLength) {\n        var name;\n\n        if (typeof func !== \"function\") {\n            func = function () { };\n        } else {\n            name = functionName(func);\n        }\n\n        if (!spyLength) {\n            spyLength = func.length;\n        }\n\n        var proxy = createProxy(func, spyLength);\n\n        extend(proxy, spy);\n        delete proxy.create;\n        extend(proxy, func);\n\n        proxy.reset();\n        proxy.prototype = func.prototype;\n        proxy.displayName = name || \"spy\";\n        proxy.toString = functionToString;\n        proxy.instantiateFake = spy.create;\n        proxy.id = \"spy#\" + uuid++;\n\n        return proxy;\n    },\n\n    invoke: function invoke(func, thisValue, args) {\n        var matching = matchingFake(this.fakes, args);\n        var exception, returnValue;\n\n        incrementCallCount.call(this);\n        push.call(this.thisValues, thisValue);\n        push.call(this.args, args);\n        push.call(this.callIds, callId++);\n\n        // Make call properties available from within the spied function:\n        createCallProperties.call(this);\n\n        try {\n            this.invoking = true;\n\n            if (matching) {\n                returnValue = matching.invoke(func, thisValue, args);\n            } else {\n                returnValue = (this.func || func).apply(thisValue, args);\n            }\n\n            var thisCall = this.getCall(this.callCount - 1);\n            if (thisCall.calledWithNew() && typeof returnValue !== \"object\") {\n                returnValue = thisValue;\n            }\n        } catch (e) {\n            exception = e;\n        } finally {\n            delete this.invoking;\n        }\n\n        push.call(this.exceptions, exception);\n        push.call(this.returnValues, returnValue);\n        var err = new ErrorConstructor();\n        // 1. Please do not get stack at this point. It's may be so very slow, and not actually used\n        // 2. PhantomJS does not serialize the stack trace until the error has been thrown:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack\n        try {\n            throw err;\n        } catch (e) {/* empty */}\n        push.call(this.errorsWithCallStack, err);\n\n        // Make return value and exception available in the calls:\n        createCallProperties.call(this);\n\n        if (exception !== undefined) {\n            throw exception;\n        }\n\n        return returnValue;\n    },\n\n    named: function named(name) {\n        this.displayName = name;\n        return this;\n    },\n\n    getCall: function getCall(i) {\n        if (i < 0 || i >= this.callCount) {\n            return null;\n        }\n\n        return spyCall(this, this.thisValues[i], this.args[i],\n                                this.returnValues[i], this.exceptions[i],\n                                this.callIds[i], this.errorsWithCallStack[i]);\n    },\n\n    getCalls: function () {\n        var calls = [];\n        var i;\n\n        for (i = 0; i < this.callCount; i++) {\n            calls.push(this.getCall(i));\n        }\n\n        return calls;\n    },\n\n    calledBefore: function calledBefore(spyFn) {\n        if (!this.called) {\n            return false;\n        }\n\n        if (!spyFn.called) {\n            return true;\n        }\n\n        return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];\n    },\n\n    calledAfter: function calledAfter(spyFn) {\n        if (!this.called || !spyFn.called) {\n            return false;\n        }\n\n        return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];\n    },\n\n    calledImmediatelyBefore: function calledImmediatelyBefore(spyFn) {\n        if (!this.called || !spyFn.called) {\n            return false;\n        }\n\n        return this.callIds[this.callCount - 1] === spyFn.callIds[spyFn.callCount - 1] - 1;\n    },\n\n    calledImmediatelyAfter: function calledImmediatelyAfter(spyFn) {\n        if (!this.called || !spyFn.called) {\n            return false;\n        }\n\n        return this.callIds[this.callCount - 1] === spyFn.callIds[spyFn.callCount - 1] + 1;\n    },\n\n    withArgs: function () {\n        var args = slice.call(arguments);\n\n        if (this.fakes) {\n            var match = matchingFake(this.fakes, args, true);\n\n            if (match) {\n                return match;\n            }\n        } else {\n            this.fakes = [];\n        }\n\n        var original = this;\n        var fake = this.instantiateFake();\n        fake.matchingArguments = args;\n        fake.parent = this;\n        push.call(this.fakes, fake);\n\n        fake.withArgs = function () {\n            return original.withArgs.apply(original, arguments);\n        };\n\n        original.args.forEach(function (arg, i) {\n            if (!fake.matches(arg)) {\n                return;\n            }\n\n            incrementCallCount.call(fake);\n            push.call(fake.thisValues, original.thisValues[i]);\n            push.call(fake.args, arg);\n            push.call(fake.returnValues, original.returnValues[i]);\n            push.call(fake.exceptions, original.exceptions[i]);\n            push.call(fake.callIds, original.callIds[i]);\n        });\n\n        createCallProperties.call(fake);\n\n        return fake;\n    },\n\n    matches: function (args, strict) {\n        var margs = this.matchingArguments;\n\n        if (margs.length <= args.length &&\n            deepEqual(margs, args.slice(0, margs.length))) {\n            return !strict || margs.length === args.length;\n        }\n\n        return undefined;\n    },\n\n    printf: function (format) {\n        var spyInstance = this;\n        var args = slice.call(arguments, 1);\n        var formatter;\n\n        return (format || \"\").replace(/%(.)/g, function (match, specifyer) {\n            formatter = spyApi.formatters[specifyer];\n\n            if (typeof formatter === \"function\") {\n                return formatter.call(null, spyInstance, args);\n            } else if (!isNaN(parseInt(specifyer, 10))) {\n                return sinonFormat(args[specifyer - 1]);\n            }\n\n            return \"%\" + specifyer;\n        });\n    }\n};\n\nfunction delegateToCalls(method, matchAny, actual, notCalled) {\n    spyApi[method] = function () {\n        if (!this.called) {\n            if (notCalled) {\n                return notCalled.apply(this, arguments);\n            }\n            return false;\n        }\n\n        var currentCall;\n        var matches = 0;\n\n        for (var i = 0, l = this.callCount; i < l; i += 1) {\n            currentCall = this.getCall(i);\n\n            if (currentCall[actual || method].apply(currentCall, arguments)) {\n                matches += 1;\n\n                if (matchAny) {\n                    return true;\n                }\n            }\n        }\n\n        return matches === this.callCount;\n    };\n}\n\ndelegateToCalls(\"calledOn\", true);\ndelegateToCalls(\"alwaysCalledOn\", false, \"calledOn\");\ndelegateToCalls(\"calledWith\", true);\ndelegateToCalls(\"calledWithMatch\", true);\ndelegateToCalls(\"alwaysCalledWith\", false, \"calledWith\");\ndelegateToCalls(\"alwaysCalledWithMatch\", false, \"calledWithMatch\");\ndelegateToCalls(\"calledWithExactly\", true);\ndelegateToCalls(\"alwaysCalledWithExactly\", false, \"calledWithExactly\");\ndelegateToCalls(\"neverCalledWith\", false, \"notCalledWith\", function () {\n    return true;\n});\ndelegateToCalls(\"neverCalledWithMatch\", false, \"notCalledWithMatch\", function () {\n    return true;\n});\ndelegateToCalls(\"threw\", true);\ndelegateToCalls(\"alwaysThrew\", false, \"threw\");\ndelegateToCalls(\"returned\", true);\ndelegateToCalls(\"alwaysReturned\", false, \"returned\");\ndelegateToCalls(\"calledWithNew\", true);\ndelegateToCalls(\"alwaysCalledWithNew\", false, \"calledWithNew\");\ndelegateToCalls(\"callArg\", false, \"callArgWith\", function () {\n    throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\n});\nspyApi.callArgWith = spyApi.callArg;\ndelegateToCalls(\"callArgOn\", false, \"callArgOnWith\", function () {\n    throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\n});\nspyApi.callArgOnWith = spyApi.callArgOn;\ndelegateToCalls(\"yield\", false, \"yield\", function () {\n    throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\n});\n// \"invokeCallback\" is an alias for \"yield\" since \"yield\" is invalid in strict mode.\nspyApi.invokeCallback = spyApi.yield;\ndelegateToCalls(\"yieldOn\", false, \"yieldOn\", function () {\n    throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\n});\ndelegateToCalls(\"yieldTo\", false, \"yieldTo\", function (property) {\n    throw new Error(this.toString() + \" cannot yield to '\" + valueToString(property) +\n        \"' since it was not yet invoked.\");\n});\ndelegateToCalls(\"yieldToOn\", false, \"yieldToOn\", function (property) {\n    throw new Error(this.toString() + \" cannot yield to '\" + valueToString(property) +\n        \"' since it was not yet invoked.\");\n});\n\nextend(spy, spyApi);\nspy.spyCall = spyCall;\nmodule.exports = spy;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/call.js":"\"use strict\";\n\nvar sinonMatch = require(\"./match\");\nvar deepEqual = require(\"./util/core/deep-equal\").use(sinonMatch);\nvar functionName = require(\"./util/core/function-name\");\nvar sinonFormat = require(\"./util/core/format\");\nvar valueToString = require(\"./util/core/value-to-string\");\nvar slice = Array.prototype.slice;\n\nfunction throwYieldError(proxy, text, args) {\n    var msg = functionName(proxy) + text;\n    if (args.length) {\n        msg += \" Received [\" + slice.call(args).join(\", \") + \"]\";\n    }\n    throw new Error(msg);\n}\n\nvar callProto = {\n    calledOn: function calledOn(thisValue) {\n        if (sinonMatch && sinonMatch.isMatcher(thisValue)) {\n            return thisValue.test(this.thisValue);\n        }\n        return this.thisValue === thisValue;\n    },\n\n    calledWith: function calledWith() {\n        var self = this;\n        var calledWithArgs = slice.call(arguments);\n\n        if (calledWithArgs.length > self.args.length) {\n            return false;\n        }\n\n        return calledWithArgs.reduce(function (prev, arg, i) {\n            return prev && deepEqual(arg, self.args[i]);\n        }, true);\n    },\n\n    calledWithMatch: function calledWithMatch() {\n        var self = this;\n        var calledWithMatchArgs = slice.call(arguments);\n\n        if (calledWithMatchArgs.length > self.args.length) {\n            return false;\n        }\n\n        return calledWithMatchArgs.reduce(function (prev, expectation, i) {\n            var actual = self.args[i];\n\n            return prev && (sinonMatch && sinonMatch(expectation).test(actual));\n        }, true);\n    },\n\n    calledWithExactly: function calledWithExactly() {\n        return arguments.length === this.args.length &&\n            this.calledWith.apply(this, arguments);\n    },\n\n    notCalledWith: function notCalledWith() {\n        return !this.calledWith.apply(this, arguments);\n    },\n\n    notCalledWithMatch: function notCalledWithMatch() {\n        return !this.calledWithMatch.apply(this, arguments);\n    },\n\n    returned: function returned(value) {\n        return deepEqual(value, this.returnValue);\n    },\n\n    threw: function threw(error) {\n        if (typeof error === \"undefined\" || !this.exception) {\n            return !!this.exception;\n        }\n\n        return this.exception === error || this.exception.name === error;\n    },\n\n    calledWithNew: function calledWithNew() {\n        return this.proxy.prototype && this.thisValue instanceof this.proxy;\n    },\n\n    calledBefore: function (other) {\n        return this.callId < other.callId;\n    },\n\n    calledAfter: function (other) {\n        return this.callId > other.callId;\n    },\n\n    calledImmediatelyBefore: function (other) {\n        return this.callId === other.callId - 1;\n    },\n\n    calledImmediatelyAfter: function (other) {\n        return this.callId === other.callId + 1;\n    },\n\n    callArg: function (pos) {\n        this.args[pos]();\n    },\n\n    callArgOn: function (pos, thisValue) {\n        this.args[pos].apply(thisValue);\n    },\n\n    callArgWith: function (pos) {\n        this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));\n    },\n\n    callArgOnWith: function (pos, thisValue) {\n        var args = slice.call(arguments, 2);\n        this.args[pos].apply(thisValue, args);\n    },\n\n    \"yield\": function () {\n        this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));\n    },\n\n    yieldOn: function (thisValue) {\n        var args = slice.call(this.args);\n        var yieldFn = args.filter(function (arg) {\n            return typeof arg === \"function\";\n        })[0];\n\n        if (!yieldFn) {\n            throwYieldError(this.proxy, \" cannot yield since no callback was passed.\", args);\n        }\n\n        yieldFn.apply(thisValue, slice.call(arguments, 1));\n    },\n\n    yieldTo: function (prop) {\n        this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));\n    },\n\n    yieldToOn: function (prop, thisValue) {\n        var args = slice.call(this.args);\n        var yieldArg = args.filter(function (arg) {\n            return arg && typeof arg[prop] === \"function\";\n        })[0];\n        var yieldFn = yieldArg && yieldArg[prop];\n\n        if (!yieldFn) {\n            throwYieldError(this.proxy, \" cannot yield to '\" + valueToString(prop) +\n                \"' since no callback was passed.\", args);\n        }\n\n        yieldFn.apply(thisValue, slice.call(arguments, 2));\n    },\n\n    toString: function () {\n        var callStr = this.proxy ? this.proxy.toString() + \"(\" : \"\";\n        var formattedArgs;\n\n        if (!this.args) {\n            return \":(\";\n        }\n\n        formattedArgs = slice.call(this.args).map(function (arg) {\n            return sinonFormat(arg);\n        });\n\n        callStr = callStr + formattedArgs.join(\", \") + \")\";\n\n        if (typeof this.returnValue !== \"undefined\") {\n            callStr += \" => \" + sinonFormat(this.returnValue);\n        }\n\n        if (this.exception) {\n            callStr += \" !\" + this.exception.name;\n\n            if (this.exception.message) {\n                callStr += \"(\" + this.exception.message + \")\";\n            }\n        }\n        if (this.stack) {\n            // Omit the error message and the two top stack frames in sinon itself:\n            callStr += this.stack.split(\"\\n\")[3].replace(/^\\s*(?:at\\s+|@)?/, \" at \");\n        }\n\n        return callStr;\n    }\n};\nObject.defineProperty(callProto, \"stack\", {\n    enumerable: true,\n    configurable: true,\n    get: function () {\n        return this.errorWithCallStack && this.errorWithCallStack.stack || \"\";\n    }\n});\n\ncallProto.invokeCallback = callProto.yield;\n\nfunction createSpyCall(spy, thisValue, args, returnValue, exception, id, errorWithCallStack) {\n    if (typeof id !== \"number\") {\n        throw new TypeError(\"Call id is not a number\");\n    }\n    var proxyCall = Object.create(callProto);\n    proxyCall.proxy = spy;\n    proxyCall.thisValue = thisValue;\n    proxyCall.args = args;\n    proxyCall.returnValue = returnValue;\n    proxyCall.exception = exception;\n    proxyCall.callId = id;\n    proxyCall.errorWithCallStack = errorWithCallStack;\n\n    return proxyCall;\n}\ncreateSpyCall.toString = callProto.toString; // used by mocks\n\nmodule.exports = createSpyCall;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/spy-formatters.js":"\"use strict\";\n\nvar color = require(\"./color\");\nvar timesInWords = require(\"./util/core/times-in-words\");\nvar sinonFormat = require(\"./util/core/format\");\nvar sinonMatch = require(\"./match\");\nvar jsDiff = require(\"diff\");\nvar push = Array.prototype.push;\n\nfunction colorSinonMatchText(matcher, calledArg, calledArgMessage) {\n    if (!matcher.test(calledArg)) {\n        matcher.message = color.red(matcher.message);\n        if (calledArgMessage) {\n            calledArgMessage = color.green(calledArgMessage);\n        }\n    }\n    return calledArgMessage + \" \" + matcher.message;\n}\n\nfunction colorDiffText(diff) {\n    var objects = diff.map(function (part) {\n        var text = part.value;\n        if (part.added) {\n            text = color.green(text);\n        } else if (part.removed) {\n            text = color.red(text);\n        }\n        if (diff.length === 2) {\n            text += \" \"; // format simple diffs\n        }\n        return text;\n    });\n    return objects.join(\"\");\n}\n\nmodule.exports = {\n    c: function (spyInstance) {\n        return timesInWords(spyInstance.callCount);\n    },\n\n    n: function (spyInstance) {\n        return spyInstance.toString();\n    },\n\n    D: function (spyInstance, args) {\n        var message = \"\";\n\n        for (var i = 0, l = spyInstance.callCount; i < l; ++i) {\n            // describe multiple calls\n            if (l > 1) {\n                if (i > 0) {\n                    message += \"\\n\";\n                }\n                message += \"Call \" + (i + 1) + \":\";\n            }\n            var calledArgs = spyInstance.getCall(i).args;\n            for (var j = 0; j < calledArgs.length || j < args.length; ++j) {\n                message += \"\\n\";\n                var calledArgMessage = j < calledArgs.length ? sinonFormat(calledArgs[j]) : \"\";\n                if (sinonMatch.isMatcher(args[j])) {\n                    message += colorSinonMatchText(args[j], calledArgs[j], calledArgMessage);\n                } else {\n                    var expectedArgMessage = j < args.length ? sinonFormat(args[j]) : \"\";\n                    var diff = jsDiff.diffJson(calledArgMessage, expectedArgMessage);\n                    message += colorDiffText(diff);\n                }\n            }\n        }\n\n        return message;\n    },\n\n    C: function (spyInstance) {\n        var calls = [];\n\n        for (var i = 0, l = spyInstance.callCount; i < l; ++i) {\n            var stringifiedCall = \"    \" + spyInstance.getCall(i).toString();\n            if (/\\n/.test(calls[i - 1])) {\n                stringifiedCall = \"\\n\" + stringifiedCall;\n            }\n            push.call(calls, stringifiedCall);\n        }\n\n        return calls.length > 0 ? \"\\n\" + calls.join(\"\\n\") : \"\";\n    },\n\n    t: function (spyInstance) {\n        var objects = [];\n\n        for (var i = 0, l = spyInstance.callCount; i < l; ++i) {\n            push.call(objects, sinonFormat(spyInstance.thisValues[i]));\n        }\n\n        return objects.join(\", \");\n    },\n\n    \"*\": function (spyInstance, args) {\n        return args.map(function (arg) { return sinonFormat(arg); }).join(\", \");\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/color.js":"\"use strict\";\n\nvar canColor = typeof process !== \"undefined\";\n\nfunction colorize(str, color) {\n    if (!canColor) {\n        return str;\n    }\n\n    return \"\\x1b[\" + color + \"m\" + str + \"\\x1b[0m\";\n}\n\nexports.red = function (str) {\n    return colorize(str, 31);\n};\n\nexports.green = function (str) {\n    return colorize(str, 32);\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/stub.js":"\"use strict\";\n\nvar behavior = require(\"./behavior\");\nvar behaviors = require(\"./default-behaviors\");\nvar spy = require(\"./spy\");\nvar extend = require(\"./util/core/extend\");\nvar functionToString = require(\"./util/core/function-to-string\");\nvar getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\nvar wrapMethod = require(\"./util/core/wrap-method\");\nvar stubEntireObject = require(\"./stub-entire-object\");\nvar stubDescriptor = require(\"./stub-descriptor\");\nvar throwOnFalsyObject = require(\"./throw-on-falsy-object\");\n\nfunction stub(object, property, descriptor) {\n    throwOnFalsyObject.apply(null, arguments);\n\n    var actualDescriptor = getPropertyDescriptor(object, property);\n    var isStubbingEntireObject = typeof property === \"undefined\" && typeof object === \"object\";\n    var isCreatingNewStub = !object && typeof property === \"undefined\";\n    var isStubbingDescriptor = object && property && Boolean(descriptor);\n    var isStubbingNonFuncProperty = typeof object === \"object\"\n                                    && typeof property !== \"undefined\"\n                                    && (typeof actualDescriptor === \"undefined\"\n                                    || typeof actualDescriptor.value !== \"function\")\n                                    && typeof descriptor === \"undefined\";\n    var isStubbingExistingMethod = !isStubbingDescriptor\n                                    && typeof object === \"object\"\n                                    && typeof actualDescriptor !== \"undefined\"\n                                    && typeof actualDescriptor.value === \"function\";\n    var arity = isStubbingExistingMethod ? object[property].length : 0;\n\n    if (isStubbingEntireObject) {\n        return stubEntireObject(stub, object);\n    }\n\n    if (isStubbingDescriptor) {\n        return stubDescriptor.apply(null, arguments);\n    }\n\n    if (isCreatingNewStub) {\n        return stub.create();\n    }\n\n    var s = stub.create(arity);\n    s.rootObj = object;\n    s.propName = property;\n    s.restore = function restore() {\n        Object.defineProperty(object, property, actualDescriptor);\n    };\n\n    return isStubbingNonFuncProperty ? s : wrapMethod(object, property, s);\n}\n\nstub.createStubInstance = function (constructor) {\n    if (typeof constructor !== \"function\") {\n        throw new TypeError(\"The constructor should be a function.\");\n    }\n    return stub(Object.create(constructor.prototype));\n};\n\n/*eslint-disable no-use-before-define*/\nfunction getParentBehaviour(stubInstance) {\n    return (stubInstance.parent && getCurrentBehavior(stubInstance.parent));\n}\n\nfunction getDefaultBehavior(stubInstance) {\n    return stubInstance.defaultBehavior ||\n            getParentBehaviour(stubInstance) ||\n            behavior.create(stubInstance);\n}\n\nfunction getCurrentBehavior(stubInstance) {\n    var currentBehavior = stubInstance.behaviors[stubInstance.callCount - 1];\n    return currentBehavior && currentBehavior.isPresent() ? currentBehavior : getDefaultBehavior(stubInstance);\n}\n/*eslint-enable no-use-before-define*/\n\nvar uuid = 0;\n\nvar proto = {\n    create: function create(stubLength) {\n        var functionStub = function () {\n            return getCurrentBehavior(functionStub).invoke(this, arguments);\n        };\n\n        functionStub.id = \"stub#\" + uuid++;\n        var orig = functionStub;\n        functionStub = spy.create(functionStub, stubLength);\n        functionStub.func = orig;\n\n        extend(functionStub, stub);\n        functionStub.instantiateFake = stub.create;\n        functionStub.displayName = \"stub\";\n        functionStub.toString = functionToString;\n\n        functionStub.defaultBehavior = null;\n        functionStub.behaviors = [];\n\n        return functionStub;\n    },\n\n    resetBehavior: function () {\n        var fakes = this.fakes || [];\n\n        this.defaultBehavior = null;\n        this.behaviors = [];\n\n        delete this.returnValue;\n        delete this.returnArgAt;\n        delete this.fakeFn;\n        this.returnThis = false;\n\n        fakes.forEach(function (fake) {\n            fake.resetBehavior();\n        });\n    },\n\n    resetHistory: spy.reset,\n\n    reset: function () {\n        this.resetHistory();\n        this.resetBehavior();\n    },\n\n    onCall: function onCall(index) {\n        if (!this.behaviors[index]) {\n            this.behaviors[index] = behavior.create(this);\n        }\n\n        return this.behaviors[index];\n    },\n\n    onFirstCall: function onFirstCall() {\n        return this.onCall(0);\n    },\n\n    onSecondCall: function onSecondCall() {\n        return this.onCall(1);\n    },\n\n    onThirdCall: function onThirdCall() {\n        return this.onCall(2);\n    }\n};\n\nObject.keys(behavior).forEach(function (method) {\n    if (behavior.hasOwnProperty(method) &&\n        !proto.hasOwnProperty(method) &&\n        method !== \"create\" &&\n        method !== \"withArgs\" &&\n        method !== \"invoke\") {\n        proto[method] = behavior.createBehavior(method);\n    }\n});\n\nObject.keys(behaviors).forEach(function (method) {\n    if (behaviors.hasOwnProperty(method) && !proto.hasOwnProperty(method)) {\n        behavior.addBehavior(stub, method, behaviors[method]);\n    }\n});\n\nextend(stub, proto);\nmodule.exports = stub;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/behavior.js":"\"use strict\";\n\nvar extend = require(\"./util/core/extend\");\nvar functionName = require(\"./util/core/function-name\");\nvar valueToString = require(\"./util/core/value-to-string\");\n\nvar slice = Array.prototype.slice;\nvar join = Array.prototype.join;\nvar useLeftMostCallback = -1;\nvar useRightMostCallback = -2;\n\nvar nextTick = (function () {\n    if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n        return process.nextTick;\n    }\n\n    if (typeof setImmediate === \"function\") {\n        return setImmediate;\n    }\n\n    return function (callback) {\n        setTimeout(callback, 0);\n    };\n})();\n\nfunction getCallback(behavior, args) {\n    var callArgAt = behavior.callArgAt;\n\n    if (callArgAt >= 0) {\n        return args[callArgAt];\n    }\n\n    var argumentList;\n\n    if (callArgAt === useLeftMostCallback) {\n        argumentList = args;\n    }\n\n    if (callArgAt === useRightMostCallback) {\n        argumentList = slice.call(args).reverse();\n    }\n\n    var callArgProp = behavior.callArgProp;\n\n    for (var i = 0, l = argumentList.length; i < l; ++i) {\n        if (!callArgProp && typeof argumentList[i] === \"function\") {\n            return argumentList[i];\n        }\n\n        if (callArgProp && argumentList[i] &&\n            typeof argumentList[i][callArgProp] === \"function\") {\n            return argumentList[i][callArgProp];\n        }\n    }\n\n    return null;\n}\n\nfunction getCallbackError(behavior, func, args) {\n    if (behavior.callArgAt < 0) {\n        var msg;\n\n        if (behavior.callArgProp) {\n            msg = functionName(behavior.stub) +\n                \" expected to yield to '\" + valueToString(behavior.callArgProp) +\n                \"', but no object with such a property was passed.\";\n        } else {\n            msg = functionName(behavior.stub) +\n                \" expected to yield, but no callback was passed.\";\n        }\n\n        if (args.length > 0) {\n            msg += \" Received [\" + join.call(args, \", \") + \"]\";\n        }\n\n        return msg;\n    }\n\n    return \"argument at index \" + behavior.callArgAt + \" is not a function: \" + func;\n}\n\nfunction callCallback(behavior, args) {\n    if (typeof behavior.callArgAt === \"number\") {\n        var func = getCallback(behavior, args);\n\n        if (typeof func !== \"function\") {\n            throw new TypeError(getCallbackError(behavior, func, args));\n        }\n\n        if (behavior.callbackAsync) {\n            nextTick(function () {\n                func.apply(behavior.callbackContext, behavior.callbackArguments);\n            });\n        } else {\n            func.apply(behavior.callbackContext, behavior.callbackArguments);\n        }\n    }\n}\n\nvar proto = {\n    create: function create(stub) {\n        var behavior = extend({}, proto);\n        delete behavior.create;\n        delete behavior.addBehavior;\n        delete behavior.createBehavior;\n        behavior.stub = stub;\n\n        return behavior;\n    },\n\n    isPresent: function isPresent() {\n        return (typeof this.callArgAt === \"number\" ||\n                this.exception ||\n                typeof this.returnArgAt === \"number\" ||\n                this.returnThis ||\n                this.fakeFn ||\n                this.returnValueDefined);\n    },\n\n    invoke: function invoke(context, args) {\n        callCallback(this, args);\n\n        if (this.exception) {\n            throw this.exception;\n        } else if (typeof this.returnArgAt === \"number\") {\n            return args[this.returnArgAt];\n        } else if (this.returnThis) {\n            return context;\n        } else if (this.fakeFn) {\n            return this.fakeFn.apply(context, args);\n        } else if (this.resolve) {\n            return Promise.resolve(this.returnValue);\n        } else if (this.reject) {\n            return Promise.reject(this.returnValue);\n        } else if (this.callsThrough) {\n            return this.stub.wrappedMethod.apply(context, args);\n        }\n        return this.returnValue;\n    },\n\n    onCall: function onCall(index) {\n        return this.stub.onCall(index);\n    },\n\n    onFirstCall: function onFirstCall() {\n        return this.stub.onFirstCall();\n    },\n\n    onSecondCall: function onSecondCall() {\n        return this.stub.onSecondCall();\n    },\n\n    onThirdCall: function onThirdCall() {\n        return this.stub.onThirdCall();\n    },\n\n    withArgs: function withArgs(/* arguments */) {\n        throw new Error(\n            \"Defining a stub by invoking \\\"stub.onCall(...).withArgs(...)\\\" \" +\n            \"is not supported. Use \\\"stub.withArgs(...).onCall(...)\\\" \" +\n            \"to define sequential behavior for calls with certain arguments.\"\n        );\n    }\n};\n\nfunction createAsyncVersion(syncFnName) {\n    return function () {\n        var result = this[syncFnName].apply(this, arguments);\n        this.callbackAsync = true;\n        return result;\n    };\n}\n\n// create asynchronous versions of callsArg* and yields* methods\nObject.keys(proto).forEach(function (method) {\n    // need to avoid creating anotherasync versions of the newly added async methods\n    if (method.match(/^(callsArg|yields)/) && !method.match(/Async/)) {\n        proto[method + \"Async\"] = createAsyncVersion(method);\n    }\n});\n\nfunction createBehavior(behaviorMethod) {\n    return function () {\n        this.defaultBehavior = this.defaultBehavior || proto.create(this);\n        this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);\n        return this;\n    };\n}\n\nfunction addBehavior(stub, name, fn) {\n    proto[name] = function () {\n        fn.apply(this, [this].concat([].slice.call(arguments)));\n        return this.stub || this;\n    };\n\n    stub[name] = createBehavior(name);\n}\n\nproto.addBehavior = addBehavior;\nproto.createBehavior = createBehavior;\nmodule.exports = proto;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/default-behaviors.js":"\"use strict\";\n\nvar slice = [].slice;\nvar useLeftMostCallback = -1;\nvar useRightMostCallback = -2;\n\nfunction throwsException(fake, error, message) {\n    if (typeof error === \"string\") {\n        fake.exception = new Error(message || \"\");\n        fake.exception.name = error;\n    } else if (!error) {\n        fake.exception = new Error(\"Error\");\n    } else {\n        fake.exception = error;\n    }\n}\n\nmodule.exports = {\n    callsFake: function callsFake(fake, fn) {\n        fake.fakeFn = fn;\n    },\n\n    callsArg: function callsArg(fake, pos) {\n        if (typeof pos !== \"number\") {\n            throw new TypeError(\"argument index is not number\");\n        }\n\n        fake.callArgAt = pos;\n        fake.callbackArguments = [];\n        fake.callbackContext = undefined;\n        fake.callArgProp = undefined;\n        fake.callbackAsync = false;\n    },\n\n    callsArgOn: function callsArgOn(fake, pos, context) {\n        if (typeof pos !== \"number\") {\n            throw new TypeError(\"argument index is not number\");\n        }\n\n        fake.callArgAt = pos;\n        fake.callbackArguments = [];\n        fake.callbackContext = context;\n        fake.callArgProp = undefined;\n        fake.callbackAsync = false;\n    },\n\n    callsArgWith: function callsArgWith(fake, pos) {\n        if (typeof pos !== \"number\") {\n            throw new TypeError(\"argument index is not number\");\n        }\n\n        fake.callArgAt = pos;\n        fake.callbackArguments = slice.call(arguments, 2);\n        fake.callbackContext = undefined;\n        fake.callArgProp = undefined;\n        fake.callbackAsync = false;\n    },\n\n    callsArgOnWith: function callsArgWith(fake, pos, context) {\n        if (typeof pos !== \"number\") {\n            throw new TypeError(\"argument index is not number\");\n        }\n\n        fake.callArgAt = pos;\n        fake.callbackArguments = slice.call(arguments, 3);\n        fake.callbackContext = context;\n        fake.callArgProp = undefined;\n        fake.callbackAsync = false;\n    },\n\n    yields: function (fake) {\n        fake.callArgAt = useLeftMostCallback;\n        fake.callbackArguments = slice.call(arguments, 1);\n        fake.callbackContext = undefined;\n        fake.callArgProp = undefined;\n        fake.callbackAsync = false;\n    },\n\n    yieldsRight: function (fake) {\n        fake.callArgAt = useRightMostCallback;\n        fake.callbackArguments = slice.call(arguments, 1);\n        fake.callbackContext = undefined;\n        fake.callArgProp = undefined;\n        fake.callbackAsync = false;\n    },\n\n    yieldsOn: function (fake, context) {\n        fake.callArgAt = useLeftMostCallback;\n        fake.callbackArguments = slice.call(arguments, 2);\n        fake.callbackContext = context;\n        fake.callArgProp = undefined;\n        fake.callbackAsync = false;\n    },\n\n    yieldsTo: function (fake, prop) {\n        fake.callArgAt = useLeftMostCallback;\n        fake.callbackArguments = slice.call(arguments, 2);\n        fake.callbackContext = undefined;\n        fake.callArgProp = prop;\n        fake.callbackAsync = false;\n    },\n\n    yieldsToOn: function (fake, prop, context) {\n        fake.callArgAt = useLeftMostCallback;\n        fake.callbackArguments = slice.call(arguments, 3);\n        fake.callbackContext = context;\n        fake.callArgProp = prop;\n        fake.callbackAsync = false;\n    },\n\n    throws: throwsException,\n    throwsException: throwsException,\n\n    returns: function returns(fake, value) {\n        fake.returnValue = value;\n        fake.resolve = false;\n        fake.reject = false;\n        fake.returnValueDefined = true;\n        fake.exception = undefined;\n        fake.fakeFn = undefined;\n    },\n\n    returnsArg: function returnsArg(fake, pos) {\n        if (typeof pos !== \"number\") {\n            throw new TypeError(\"argument index is not number\");\n        }\n\n        fake.returnArgAt = pos;\n    },\n\n    returnsThis: function returnsThis(fake) {\n        fake.returnThis = true;\n    },\n\n    resolves: function resolves(fake, value) {\n        fake.returnValue = value;\n        fake.resolve = true;\n        fake.reject = false;\n        fake.returnValueDefined = true;\n        fake.exception = undefined;\n        fake.fakeFn = undefined;\n    },\n\n    rejects: function rejects(fake, error, message) {\n        var reason;\n        if (typeof error === \"string\") {\n            reason = new Error(message || \"\");\n            reason.name = error;\n        } else if (!error) {\n            reason = new Error(\"Error\");\n        } else {\n            reason = error;\n        }\n        fake.returnValue = reason;\n        fake.resolve = false;\n        fake.reject = true;\n        fake.returnValueDefined = true;\n        fake.exception = undefined;\n        fake.fakeFn = undefined;\n\n        return fake;\n    },\n\n    callThrough: function callThrough(fake) {\n        fake.callsThrough = true;\n    },\n\n    get: function get(fake, getterFunction) {\n        var rootStub = fake.stub || fake;\n\n        Object.defineProperty(rootStub.rootObj, rootStub.propName, {\n            get: getterFunction\n        });\n\n        return fake;\n    },\n\n    set: function set(fake, setterFunction) {\n        var rootStub = fake.stub || fake;\n\n        Object.defineProperty(rootStub.rootObj, rootStub.propName, { // eslint-disable-line accessor-pairs\n            set: setterFunction\n        });\n\n        return fake;\n    }\n};\n\nfunction createAsyncVersion(syncFnName) {\n    return function () {\n        var result = module.exports[syncFnName].apply(this, arguments);\n        this.callbackAsync = true;\n        return result;\n    };\n}\n\n// create asynchronous versions of callsArg* and yields* methods\nObject.keys(module.exports).forEach(function (method) {\n    // need to avoid creating anotherasync versions of the newly added async methods\n    if (method.match(/^(callsArg|yields)/) && !method.match(/Async/)) {\n        module.exports[method + \"Async\"] = createAsyncVersion(method);\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/stub-entire-object.js":"\"use strict\";\n\nvar getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\nvar walk = require(\"./util/core/walk\");\n\nfunction stubEntireObject(stub, object) {\n    walk(object || {}, function (prop, propOwner) {\n        // we don't want to stub things like toString(), valueOf(), etc. so we only stub if the object\n        // is not Object.prototype\n        if (\n            propOwner !== Object.prototype &&\n            prop !== \"constructor\" &&\n            typeof getPropertyDescriptor(propOwner, prop).value === \"function\"\n        ) {\n            stub(object, prop);\n        }\n    });\n\n    return object;\n}\n\nmodule.exports = stubEntireObject;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/stub-descriptor.js":"\"use strict\";\n\nvar deprecated = require(\"./util/core/deprecated\");\nvar spy = require(\"./spy\");\nvar wrapMethod = require(\"./util/core/wrap-method\");\n\n// This is deprecated and will be removed in a future version of sinon.\n// We will only consider pull requests that fix serious bugs in the implementation\nfunction stubDescriptor(object, property, descriptor) {\n    var wrapper;\n\n    deprecated.printWarning(\n      \"sinon.stub(obj, 'meth', fn) is deprecated and will be removed from \" +\n      \"the public API in a future version of sinon.\" +\n      \"\\n Use stub(obj, 'meth').callsFake(fn).\" +\n      \"\\n Codemod available at https://github.com/hurrymaplelad/sinon-codemod\"\n    );\n\n    if (!!descriptor && typeof descriptor !== \"function\" && typeof descriptor !== \"object\") {\n        throw new TypeError(\"Custom stub should be a property descriptor\");\n    }\n\n    if (typeof descriptor === \"object\" && Object.keys(descriptor).length === 0) {\n        throw new TypeError(\"Expected property descriptor to have at least one key\");\n    }\n\n    if (typeof descriptor === \"function\") {\n        wrapper = spy && spy.create ? spy.create(descriptor) : descriptor;\n    } else {\n        wrapper = descriptor;\n        if (spy && spy.create) {\n            Object.keys(wrapper).forEach(function (type) {\n                wrapper[type] = spy.create(wrapper[type]);\n            });\n        }\n    }\n\n    return wrapMethod(object, property, wrapper);\n}\n\nmodule.exports = stubDescriptor;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/throw-on-falsy-object.js":"\"use strict\";\nvar valueToString = require(\"./util/core/value-to-string\");\n\nfunction throwOnFalsyObject(object, property) {\n    if (property && !object) {\n        var type = object === null ? \"null\" : \"undefined\";\n        throw new Error(\"Trying to stub property '\" + valueToString(property) + \"' of \" + type);\n    }\n}\n\nmodule.exports = throwOnFalsyObject;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/mock.js":"\"use strict\";\n\nvar mockExpectation = require(\"./mock-expectation\");\nvar spyCallToString = require(\"./call\").toString;\nvar extend = require(\"./util/core/extend\");\nvar match = require(\"./match\");\nvar deepEqual = require(\"./util/core/deep-equal\").use(match);\nvar wrapMethod = require(\"./util/core/wrap-method\");\n\nvar push = Array.prototype.push;\n\nfunction mock(object) {\n    if (!object) {\n        return mockExpectation.create(\"Anonymous mock\");\n    }\n\n    return mock.create(object);\n}\n\nfunction each(collection, callback) {\n    var col = collection || [];\n\n    col.forEach(callback);\n}\n\nfunction arrayEquals(arr1, arr2, compareLength) {\n    if (compareLength && (arr1.length !== arr2.length)) {\n        return false;\n    }\n\n    return arr1.every(function (element, i) {\n        return deepEqual(element, arr2[i]);\n\n    });\n}\n\nextend(mock, {\n    create: function create(object) {\n        if (!object) {\n            throw new TypeError(\"object is null\");\n        }\n\n        var mockObject = extend({}, mock);\n        mockObject.object = object;\n        delete mockObject.create;\n\n        return mockObject;\n    },\n\n    expects: function expects(method) {\n        if (!method) {\n            throw new TypeError(\"method is falsy\");\n        }\n\n        if (!this.expectations) {\n            this.expectations = {};\n            this.proxies = [];\n            this.failures = [];\n        }\n\n        if (!this.expectations[method]) {\n            this.expectations[method] = [];\n            var mockObject = this;\n\n            wrapMethod(this.object, method, function () {\n                return mockObject.invokeMethod(method, this, arguments);\n            });\n\n            push.call(this.proxies, method);\n        }\n\n        var expectation = mockExpectation.create(method);\n        push.call(this.expectations[method], expectation);\n\n        return expectation;\n    },\n\n    restore: function restore() {\n        var object = this.object;\n\n        each(this.proxies, function (proxy) {\n            if (typeof object[proxy].restore === \"function\") {\n                object[proxy].restore();\n            }\n        });\n    },\n\n    verify: function verify() {\n        var expectations = this.expectations || {};\n        var messages = this.failures ? this.failures.slice() : [];\n        var met = [];\n\n        each(this.proxies, function (proxy) {\n            each(expectations[proxy], function (expectation) {\n                if (!expectation.met()) {\n                    push.call(messages, expectation.toString());\n                } else {\n                    push.call(met, expectation.toString());\n                }\n            });\n        });\n\n        this.restore();\n\n        if (messages.length > 0) {\n            mockExpectation.fail(messages.concat(met).join(\"\\n\"));\n        } else if (met.length > 0) {\n            mockExpectation.pass(messages.concat(met).join(\"\\n\"));\n        }\n\n        return true;\n    },\n\n    invokeMethod: function invokeMethod(method, thisValue, args) {\n        /* if we cannot find any matching files we will explicitly call mockExpection#fail with error messages */\n        /* eslint consistent-return: \"off\" */\n        var expectations = this.expectations && this.expectations[method] ? this.expectations[method] : [];\n        var currentArgs = args || [];\n        var available;\n\n        var expectationsWithMatchingArgs = expectations.filter(function (expectation) {\n            var expectedArgs = expectation.expectedArguments || [];\n\n            return arrayEquals(expectedArgs, currentArgs, expectation.expectsExactArgCount);\n        });\n\n        var expectationsToApply = expectationsWithMatchingArgs.filter(function (expectation) {\n            return !expectation.met() && expectation.allowsCall(thisValue, args);\n        });\n\n        if (expectationsToApply.length > 0) {\n            return expectationsToApply[0].apply(thisValue, args);\n        }\n\n        var messages = [];\n        var exhausted = 0;\n\n        expectationsWithMatchingArgs.forEach(function (expectation) {\n            if (expectation.allowsCall(thisValue, args)) {\n                available = available || expectation;\n            } else {\n                exhausted += 1;\n            }\n        });\n\n        if (available && exhausted === 0) {\n            return available.apply(thisValue, args);\n        }\n\n        expectations.forEach(function (expectation) {\n            push.call(messages, \"    \" + expectation.toString());\n        });\n\n        messages.unshift(\"Unexpected call: \" + spyCallToString.call({\n            proxy: method,\n            args: args\n        }));\n\n        var err = new Error();\n        if (!err.stack) {\n            // PhantomJS does not serialize the stack trace until the error has been thrown\n            try {\n                throw err;\n            } catch (e) {/* empty */}\n        }\n        this.failures.push(\"Unexpected call: \" + spyCallToString.call({\n            proxy: method,\n            args: args,\n            stack: err.stack\n        }));\n\n        mockExpectation.fail(messages.join(\"\\n\"));\n    }\n});\n\nmodule.exports = mock;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/mock-expectation.js":"\"use strict\";\n\nvar spyInvoke = require(\"./spy\").invoke;\nvar spyCallToString = require(\"./call\").toString;\nvar timesInWords = require(\"./util/core/times-in-words\");\nvar extend = require(\"./util/core/extend\");\nvar match = require(\"./match\");\nvar stub = require(\"./stub\");\nvar assert = require(\"./assert\");\nvar deepEqual = require(\"./util/core/deep-equal\").use(match);\nvar format = require(\"./util/core/format\");\nvar valueToString = require(\"./util/core/value-to-string\");\n\nvar slice = Array.prototype.slice;\nvar push = Array.prototype.push;\n\nfunction callCountInWords(callCount) {\n    if (callCount === 0) {\n        return \"never called\";\n    }\n\n    return \"called \" + timesInWords(callCount);\n}\n\nfunction expectedCallCountInWords(expectation) {\n    var min = expectation.minCalls;\n    var max = expectation.maxCalls;\n\n    if (typeof min === \"number\" && typeof max === \"number\") {\n        var str = timesInWords(min);\n\n        if (min !== max) {\n            str = \"at least \" + str + \" and at most \" + timesInWords(max);\n        }\n\n        return str;\n    }\n\n    if (typeof min === \"number\") {\n        return \"at least \" + timesInWords(min);\n    }\n\n    return \"at most \" + timesInWords(max);\n}\n\nfunction receivedMinCalls(expectation) {\n    var hasMinLimit = typeof expectation.minCalls === \"number\";\n    return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n}\n\nfunction receivedMaxCalls(expectation) {\n    if (typeof expectation.maxCalls !== \"number\") {\n        return false;\n    }\n\n    return expectation.callCount === expectation.maxCalls;\n}\n\nfunction verifyMatcher(possibleMatcher, arg) {\n    var isMatcher = match && match.isMatcher(possibleMatcher);\n\n    return isMatcher && possibleMatcher.test(arg) || true;\n}\n\nvar mockExpectation = {\n    minCalls: 1,\n    maxCalls: 1,\n\n    create: function create(methodName) {\n        var expectation = extend(stub.create(), mockExpectation);\n        delete expectation.create;\n        expectation.method = methodName;\n\n        return expectation;\n    },\n\n    invoke: function invoke(func, thisValue, args) {\n        this.verifyCallAllowed(thisValue, args);\n\n        return spyInvoke.apply(this, arguments);\n    },\n\n    atLeast: function atLeast(num) {\n        if (typeof num !== \"number\") {\n            throw new TypeError(\"'\" + valueToString(num) + \"' is not number\");\n        }\n\n        if (!this.limitsSet) {\n            this.maxCalls = null;\n            this.limitsSet = true;\n        }\n\n        this.minCalls = num;\n\n        return this;\n    },\n\n    atMost: function atMost(num) {\n        if (typeof num !== \"number\") {\n            throw new TypeError(\"'\" + valueToString(num) + \"' is not number\");\n        }\n\n        if (!this.limitsSet) {\n            this.minCalls = null;\n            this.limitsSet = true;\n        }\n\n        this.maxCalls = num;\n\n        return this;\n    },\n\n    never: function never() {\n        return this.exactly(0);\n    },\n\n    once: function once() {\n        return this.exactly(1);\n    },\n\n    twice: function twice() {\n        return this.exactly(2);\n    },\n\n    thrice: function thrice() {\n        return this.exactly(3);\n    },\n\n    exactly: function exactly(num) {\n        if (typeof num !== \"number\") {\n            throw new TypeError(\"'\" + valueToString(num) + \"' is not a number\");\n        }\n\n        this.atLeast(num);\n        return this.atMost(num);\n    },\n\n    met: function met() {\n        return !this.failed && receivedMinCalls(this);\n    },\n\n    verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n        var expectedArguments = this.expectedArguments;\n\n        if (receivedMaxCalls(this)) {\n            this.failed = true;\n            mockExpectation.fail(this.method + \" already called \" + timesInWords(this.maxCalls));\n        }\n\n        if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n            mockExpectation.fail(this.method + \" called with \" + valueToString(thisValue) +\n                \" as thisValue, expected \" + valueToString(this.expectedThis));\n        }\n\n        if (!(\"expectedArguments\" in this)) {\n            return;\n        }\n\n        if (!args) {\n            mockExpectation.fail(this.method + \" received no arguments, expected \" +\n                format(expectedArguments));\n        }\n\n        if (args.length < expectedArguments.length) {\n            mockExpectation.fail(this.method + \" received too few arguments (\" + format(args) +\n                \"), expected \" + format(expectedArguments));\n        }\n\n        if (this.expectsExactArgCount &&\n            args.length !== expectedArguments.length) {\n            mockExpectation.fail(this.method + \" received too many arguments (\" + format(args) +\n                \"), expected \" + format(expectedArguments));\n        }\n\n        expectedArguments.forEach(function (expectedArgument, i) {\n            if (!verifyMatcher(expectedArgument, args[i])) {\n                mockExpectation.fail(this.method + \" received wrong arguments \" + format(args) +\n                    \", didn't match \" + expectedArguments.toString());\n            }\n\n            if (!deepEqual(expectedArgument, args[i])) {\n                mockExpectation.fail(this.method + \" received wrong arguments \" + format(args) +\n                    \", expected \" + format(expectedArguments));\n            }\n        });\n    },\n\n    allowsCall: function allowsCall(thisValue, args) {\n        var expectedArguments = this.expectedArguments;\n\n        if (this.met() && receivedMaxCalls(this)) {\n            return false;\n        }\n\n        if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n            return false;\n        }\n\n        if (!(\"expectedArguments\" in this)) {\n            return true;\n        }\n\n        args = args || [];\n\n        if (args.length < expectedArguments.length) {\n            return false;\n        }\n\n        if (this.expectsExactArgCount &&\n            args.length !== expectedArguments.length) {\n            return false;\n        }\n\n        return expectedArguments.every(function (expectedArgument, i) {\n            if (!verifyMatcher(expectedArgument, args[i])) {\n                return false;\n            }\n\n            if (!deepEqual(expectedArgument, args[i])) {\n                return false;\n            }\n\n            return true;\n        });\n    },\n\n    withArgs: function withArgs() {\n        this.expectedArguments = slice.call(arguments);\n        return this;\n    },\n\n    withExactArgs: function withExactArgs() {\n        this.withArgs.apply(this, arguments);\n        this.expectsExactArgCount = true;\n        return this;\n    },\n\n    on: function on(thisValue) {\n        this.expectedThis = thisValue;\n        return this;\n    },\n\n    toString: function () {\n        var args = (this.expectedArguments || []).slice();\n\n        if (!this.expectsExactArgCount) {\n            push.call(args, \"[...]\");\n        }\n\n        var callStr = spyCallToString.call({\n            proxy: this.method || \"anonymous mock expectation\",\n            args: args\n        });\n\n        var message = callStr.replace(\", [...\", \"[, ...\") + \" \" +\n            expectedCallCountInWords(this);\n\n        if (this.met()) {\n            return \"Expectation met: \" + message;\n        }\n\n        return \"Expected \" + message + \" (\" +\n            callCountInWords(this.callCount) + \")\";\n    },\n\n    verify: function verify() {\n        if (!this.met()) {\n            mockExpectation.fail(this.toString());\n        } else {\n            mockExpectation.pass(this.toString());\n        }\n\n        return true;\n    },\n\n    pass: function pass(message) {\n        assert.pass(message);\n    },\n\n    fail: function fail(message) {\n        var exception = new Error(message);\n        exception.name = \"ExpectationError\";\n\n        throw exception;\n    }\n};\n\nmodule.exports = mockExpectation;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/collect-own-methods.js":"\"use strict\";\n\nvar walk = require(\"./util/core/walk\");\nvar getPropertyDescriptor = require(\"./util/core/get-property-descriptor\");\n\nfunction collectMethod(methods, object, prop, propOwner) {\n    if (\n        typeof getPropertyDescriptor(propOwner, prop).value === \"function\" &&\n        object.hasOwnProperty(prop)\n    ) {\n        methods.push(object[prop]);\n    }\n}\n\n// This function returns an array of all the own methods on the passed object\nfunction collectOwnMethods(object) {\n    var methods = [];\n\n    walk(object, collectMethod.bind(null, methods, object));\n\n    return methods;\n}\n\nmodule.exports = collectOwnMethods;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/stub-non-function-property.js":"\"use strict\";\n\nvar valueToString = require(\"./util/core/value-to-string\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction stubNonFunctionProperty(object, property, value) {\n    var original = object[property];\n\n    if (!hasOwnProperty.call(object, property)) {\n        throw new TypeError(\"Cannot stub non-existent own property \" + valueToString(property));\n    }\n\n    object[property] = value;\n\n    return {\n        restore: function () {\n            object[property] = original;\n        }\n    };\n}\n\nmodule.exports = stubNonFunctionProperty;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/sandbox.js":"\"use strict\";\n\nvar extend = require(\"./util/core/extend\");\nvar sinonCollection = require(\"./collection\");\nvar sinonMatch = require(\"./match\");\nvar sinonAssert = require(\"./assert\");\nvar sinonClock = require(\"./util/fake_timers\");\nvar fakeServer = require(\"./util/fake_server\");\nvar fakeXhr = require(\"./util/fake_xml_http_request\");\nvar fakeServerWithClock = require(\"./util/fake_server_with_clock\");\n\nvar push = [].push;\n\nvar sinonSandbox = Object.create(sinonCollection);\n\nfunction exposeValue(sandbox, config, key, value) {\n    if (!value) {\n        return;\n    }\n\n    if (config.injectInto && !(key in config.injectInto)) {\n        config.injectInto[key] = value;\n        sandbox.injectedKeys.push(key);\n    } else {\n        push.call(sandbox.args, value);\n    }\n}\n\nfunction prepareSandboxFromConfig(config) {\n    var sandbox = Object.create(sinonSandbox);\n\n    if (config.useFakeServer) {\n        if (typeof config.useFakeServer === \"object\") {\n            sandbox.serverPrototype = config.useFakeServer;\n        }\n\n        sandbox.useFakeServer();\n    }\n\n    if (config.useFakeTimers) {\n        if (typeof config.useFakeTimers === \"object\") {\n            sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);\n        } else {\n            sandbox.useFakeTimers();\n        }\n    }\n\n    return sandbox;\n}\n\nextend(sinonSandbox, {\n    useFakeTimers: function useFakeTimers() {\n        this.clock = sinonClock.useFakeTimers.apply(null, arguments);\n\n        return this.add(this.clock);\n    },\n\n    serverPrototype: fakeServerWithClock,\n\n    useFakeServer: function useFakeServer() {\n        var proto = this.serverPrototype || fakeServer;\n\n        if (!proto || !proto.create) {\n            return null;\n        }\n\n        this.server = proto.create();\n        return this.add(this.server);\n    },\n\n    useFakeXMLHttpRequest: function useFakeXMLHttpRequest() {\n        var xhr = fakeXhr.useFakeXMLHttpRequest();\n        return this.add(xhr);\n    },\n\n    inject: function (obj) {\n        sinonCollection.inject.call(this, obj);\n\n        if (this.clock) {\n            obj.clock = this.clock;\n        }\n\n        if (this.server) {\n            obj.server = this.server;\n            obj.requests = this.server.requests;\n        }\n\n        obj.match = sinonMatch;\n\n        return obj;\n    },\n\n    restore: function () {\n        if (arguments.length) {\n            throw new Error(\"sandbox.restore() does not take any parameters. Perhaps you meant stub.restore()\");\n        }\n\n        sinonCollection.restore.apply(this, arguments);\n        this.restoreContext();\n    },\n\n    restoreContext: function () {\n        var injectedKeys = this.injectedKeys;\n        var injectInto = this.injectInto;\n\n        if (!injectedKeys) {\n            return;\n        }\n\n        injectedKeys.forEach(function (injectedKey) {\n            delete injectInto[injectedKey];\n        });\n\n        injectedKeys = [];\n    },\n\n    create: function (config) {\n        if (!config) {\n            return Object.create(sinonSandbox);\n        }\n\n        var sandbox = prepareSandboxFromConfig(config);\n        sandbox.args = sandbox.args || [];\n        sandbox.injectedKeys = [];\n        sandbox.injectInto = config.injectInto;\n        var exposed = sandbox.inject({});\n\n        if (config.properties) {\n            config.properties.forEach(function (prop) {\n                var value = exposed[prop] || prop === \"sandbox\" && sandbox;\n                exposeValue(sandbox, config, prop, value);\n            });\n        } else {\n            exposeValue(sandbox, config, \"sandbox\");\n        }\n\n        return sandbox;\n    },\n\n    match: sinonMatch,\n\n    assert: sinonAssert\n});\n\nmodule.exports = sinonSandbox;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/fake_timers.js":"\"use strict\";\n\nvar llx = require(\"lolex\");\n\nexports.useFakeTimers = function () {\n    var now;\n    var methods = Array.prototype.slice.call(arguments);\n\n    if (typeof methods[0] === \"string\") {\n        now = 0;\n    } else {\n        now = methods.shift();\n    }\n\n    var clock = llx.install(now || 0, methods);\n    clock.restore = clock.uninstall;\n    return clock;\n};\n\nexports.clock = {\n    create: function (now) {\n        return llx.createClock(now);\n    }\n};\n\nexports.timers = {\n    setTimeout: setTimeout,\n    clearTimeout: clearTimeout,\n    setImmediate: (typeof setImmediate !== \"undefined\" ? setImmediate : undefined),\n    clearImmediate: (typeof clearImmediate !== \"undefined\" ? clearImmediate : undefined),\n    setInterval: setInterval,\n    clearInterval: clearInterval,\n    Date: Date\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/fake_server.js":"\"use strict\";\n\nvar fakeXhr = require(\"./fake_xml_http_request\");\nvar push = [].push;\nvar format = require(\"./core/format\");\nvar configureLogError = require(\"./core/log_error\");\nvar pathToRegexp = require(\"path-to-regexp\");\n\nfunction responseArray(handler) {\n    var response = handler;\n\n    if (Object.prototype.toString.call(handler) !== \"[object Array]\") {\n        response = [200, {}, handler];\n    }\n\n    if (typeof response[2] !== \"string\") {\n        throw new TypeError(\"Fake server response body should be string, but was \" +\n                            typeof response[2]);\n    }\n\n    return response;\n}\n\nvar wloc = typeof window !== \"undefined\" ? window.location : { \"host\": \"localhost\", \"protocol\": \"http\"};\nvar rCurrLoc = new RegExp(\"^\" + wloc.protocol + \"//\" + wloc.host);\n\nfunction matchOne(response, reqMethod, reqUrl) {\n    var rmeth = response.method;\n    var matchMethod = !rmeth || rmeth.toLowerCase() === reqMethod.toLowerCase();\n    var url = response.url;\n    var matchUrl = !url || url === reqUrl || (typeof url.test === \"function\" && url.test(reqUrl));\n\n    return matchMethod && matchUrl;\n}\n\nfunction match(response, request) {\n    var requestUrl = request.url;\n\n    if (!/^https?:\\/\\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {\n        requestUrl = requestUrl.replace(rCurrLoc, \"\");\n    }\n\n    if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {\n        if (typeof response.response === \"function\") {\n            var ru = response.url;\n            var args = [request].concat(ru && typeof ru.exec === \"function\" ? ru.exec(requestUrl).slice(1) : []);\n            return response.response.apply(response, args);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nfunction incrementRequestCount() {\n    var count = ++this.requestCount;\n\n    this.requested = true;\n\n    this.requestedOnce = count === 1;\n    this.requestedTwice = count === 2;\n    this.requestedThrice = count === 3;\n\n    this.firstRequest = this.getRequest(0);\n    this.secondRequest = this.getRequest(1);\n    this.thirdRequest = this.getRequest(2);\n\n    this.lastRequest = this.getRequest(count - 1);\n}\n\nvar fakeServer = {\n    create: function (config) {\n        var server = Object.create(this);\n        server.configure(config);\n        this.xhr = fakeXhr.useFakeXMLHttpRequest();\n        server.requests = [];\n        server.requestCount = 0;\n\n        this.xhr.onCreate = function (xhrObj) {\n            xhrObj.unsafeHeadersEnabled = function () {\n                return !(server.unsafeHeadersEnabled === false);\n            };\n            server.addRequest(xhrObj);\n        };\n\n        return server;\n    },\n\n    configure: function (config) {\n        var self = this;\n        var whitelist = {\n            \"autoRespond\": true,\n            \"autoRespondAfter\": true,\n            \"respondImmediately\": true,\n            \"fakeHTTPMethods\": true,\n            \"logger\": true,\n            \"unsafeHeadersEnabled\": true\n        };\n\n        config = config || {};\n\n        Object.keys(config).forEach(function (setting) {\n            if (setting in whitelist) {\n                self[setting] = config[setting];\n            }\n        });\n\n        self.logError = configureLogError(config);\n    },\n\n    addRequest: function addRequest(xhrObj) {\n        var server = this;\n        push.call(this.requests, xhrObj);\n\n        incrementRequestCount.call(this);\n\n        xhrObj.onSend = function () {\n            server.handleRequest(this);\n\n            if (server.respondImmediately) {\n                server.respond();\n            } else if (server.autoRespond && !server.responding) {\n                setTimeout(function () {\n                    server.responding = false;\n                    server.respond();\n                }, server.autoRespondAfter || 10);\n\n                server.responding = true;\n            }\n        };\n    },\n\n    getHTTPMethod: function getHTTPMethod(request) {\n        if (this.fakeHTTPMethods && /post/i.test(request.method)) {\n            var matches = (request.requestBody || \"\").match(/_method=([^\\b;]+)/);\n            return matches ? matches[1] : request.method;\n        }\n\n        return request.method;\n    },\n\n    handleRequest: function handleRequest(xhr) {\n        if (xhr.async) {\n            if (!this.queue) {\n                this.queue = [];\n            }\n\n            push.call(this.queue, xhr);\n        } else {\n            this.processRequest(xhr);\n        }\n    },\n\n    logger: function () {\n        // no-op; override via configure()\n    },\n\n    logError: configureLogError({}),\n\n    log: function log(response, request) {\n        var str;\n\n        str = \"Request:\\n\" + format(request) + \"\\n\\n\";\n        str += \"Response:\\n\" + format(response) + \"\\n\\n\";\n\n        if (typeof this.logger === \"function\") {\n            this.logger(str);\n        }\n    },\n\n    respondWith: function respondWith(method, url, body) {\n        if (arguments.length === 1 && typeof method !== \"function\") {\n            this.response = responseArray(method);\n            return;\n        }\n\n        if (!this.responses) {\n            this.responses = [];\n        }\n\n        if (arguments.length === 1) {\n            body = method;\n            url = method = null;\n        }\n\n        if (arguments.length === 2) {\n            body = url;\n            url = method;\n            method = null;\n        }\n\n        push.call(this.responses, {\n            method: method,\n            url: typeof url === \"string\" && url !== \"\" ? pathToRegexp(url) : url,\n            response: typeof body === \"function\" ? body : responseArray(body)\n        });\n    },\n\n    respond: function respond() {\n        if (arguments.length > 0) {\n            this.respondWith.apply(this, arguments);\n        }\n\n        var queue = this.queue || [];\n        var requests = queue.splice(0, queue.length);\n        var self = this;\n\n        requests.forEach(function (request) {\n            self.processRequest(request);\n        });\n    },\n\n    processRequest: function processRequest(request) {\n        try {\n            if (request.aborted) {\n                return;\n            }\n\n            var response = this.response || [404, {}, \"\"];\n\n            if (this.responses) {\n                for (var l = this.responses.length, i = l - 1; i >= 0; i--) {\n                    if (match.call(this, this.responses[i], request)) {\n                        response = this.responses[i].response;\n                        break;\n                    }\n                }\n            }\n\n            if (request.readyState !== 4) {\n                this.log(response, request);\n\n                request.respond(response[0], response[1], response[2]);\n            }\n        } catch (e) {\n            this.logError(\"Fake server request processing\", e);\n        }\n    },\n\n    restore: function restore() {\n        return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);\n    },\n\n    getRequest: function getRequest(index) {\n        return this.requests[index] || null;\n    },\n\n    reset: function reset() {\n        this.resetBehavior();\n        this.resetHistory();\n    },\n\n    resetBehavior: function resetBehavior() {\n        this.responses.length = this.queue.length = 0;\n    },\n\n    resetHistory: function resetHistory() {\n        this.requests.length = this.requestCount = 0;\n\n        this.requestedOnce = this.requestedTwice = this.requestedThrice = this.requested = false;\n\n        this.firstRequest = this.secondRequest = this.thirdRequest = this.lastRequest = null;\n    }\n};\n\nmodule.exports = fakeServer;\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/fake_xml_http_request.js":"\"use strict\";\n\nvar TextEncoder = require(\"text-encoding\").TextEncoder;\n\nvar configureLogError = require(\"./core/log_error\");\nvar sinonEvent = require(\"./event\");\nvar extend = require(\"./core/extend\");\n\nfunction getWorkingXHR(globalScope) {\n    var supportsXHR = typeof globalScope.XMLHttpRequest !== \"undefined\";\n    if (supportsXHR) {\n        return globalScope.XMLHttpRequest;\n    }\n\n    var supportsActiveX = typeof globalScope.ActiveXObject !== \"undefined\";\n    if (supportsActiveX) {\n        return function () {\n            return new globalScope.ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n        };\n    }\n\n    return false;\n}\n\nvar supportsProgress = typeof ProgressEvent !== \"undefined\";\nvar supportsCustomEvent = typeof CustomEvent !== \"undefined\";\nvar supportsFormData = typeof FormData !== \"undefined\";\nvar supportsArrayBuffer = typeof ArrayBuffer !== \"undefined\";\nvar supportsBlob = require(\"../blob\").isSupported;\nvar isReactNative = global.navigator && global.navigator.product === \"ReactNative\";\nvar sinonXhr = { XMLHttpRequest: global.XMLHttpRequest };\nsinonXhr.GlobalXMLHttpRequest = global.XMLHttpRequest;\nsinonXhr.GlobalActiveXObject = global.ActiveXObject;\nsinonXhr.supportsActiveX = typeof sinonXhr.GlobalActiveXObject !== \"undefined\";\nsinonXhr.supportsXHR = typeof sinonXhr.GlobalXMLHttpRequest !== \"undefined\";\nsinonXhr.workingXHR = getWorkingXHR(global);\nsinonXhr.supportsCORS = isReactNative ||\n    (sinonXhr.supportsXHR && \"withCredentials\" in (new sinonXhr.GlobalXMLHttpRequest()));\n\nvar unsafeHeaders = {\n    \"Accept-Charset\": true,\n    \"Accept-Encoding\": true,\n    \"Connection\": true,\n    \"Content-Length\": true,\n    \"Cookie\": true,\n    \"Cookie2\": true,\n    \"Content-Transfer-Encoding\": true,\n    \"Date\": true,\n    \"Expect\": true,\n    \"Host\": true,\n    \"Keep-Alive\": true,\n    \"Referer\": true,\n    \"TE\": true,\n    \"Trailer\": true,\n    \"Transfer-Encoding\": true,\n    \"Upgrade\": true,\n    \"User-Agent\": true,\n    \"Via\": true\n};\n\n\nfunction EventTargetHandler() {\n    var self = this;\n    var events = [\"loadstart\", \"progress\", \"abort\", \"error\", \"load\", \"timeout\", \"loadend\"];\n\n    function addEventListener(eventName) {\n        self.addEventListener(eventName, function (event) {\n            var listener = self[\"on\" + eventName];\n\n            if (listener && typeof listener === \"function\") {\n                listener.call(this, event);\n            }\n        });\n    }\n\n    events.forEach(addEventListener);\n}\n\nEventTargetHandler.prototype = sinonEvent.EventTarget;\n\n// Note that for FakeXMLHttpRequest to work pre ES5\n// we lose some of the alignment with the spec.\n// To ensure as close a match as possible,\n// set responseType before calling open, send or respond;\nfunction FakeXMLHttpRequest(config) {\n    EventTargetHandler.call(this);\n    this.readyState = FakeXMLHttpRequest.UNSENT;\n    this.requestHeaders = {};\n    this.requestBody = null;\n    this.status = 0;\n    this.statusText = \"\";\n    this.upload = new EventTargetHandler();\n    this.responseType = \"\";\n    this.response = \"\";\n    this.logError = configureLogError(config);\n    if (sinonXhr.supportsCORS) {\n        this.withCredentials = false;\n    }\n\n    if (typeof FakeXMLHttpRequest.onCreate === \"function\") {\n        FakeXMLHttpRequest.onCreate(this);\n    }\n}\n\nfunction verifyState(xhr) {\n    if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n        throw new Error(\"INVALID_STATE_ERR\");\n    }\n\n    if (xhr.sendFlag) {\n        throw new Error(\"INVALID_STATE_ERR\");\n    }\n}\n\nfunction getHeader(headers, header) {\n    var foundHeader = Object.keys(headers).filter(function (h) {\n        return h.toLowerCase() === header.toLowerCase();\n    });\n\n    return foundHeader[0] || null;\n}\n\nfunction excludeSetCookie2Header(header) {\n    return !/^Set-Cookie2?$/i.test(header);\n}\n\n// largest arity in XHR is 5 - XHR#open\nvar apply = function (obj, method, args) {\n    switch (args.length) {\n        case 0: return obj[method]();\n        case 1: return obj[method](args[0]);\n        case 2: return obj[method](args[0], args[1]);\n        case 3: return obj[method](args[0], args[1], args[2]);\n        case 4: return obj[method](args[0], args[1], args[2], args[3]);\n        case 5: return obj[method](args[0], args[1], args[2], args[3], args[4]);\n        default: throw new Error(\"Unhandled case\");\n    }\n};\n\nFakeXMLHttpRequest.filters = [];\nFakeXMLHttpRequest.addFilter = function addFilter(fn) {\n    this.filters.push(fn);\n};\nFakeXMLHttpRequest.defake = function defake(fakeXhr, xhrArgs) {\n    var xhr = new sinonXhr.workingXHR(); // eslint-disable-line new-cap\n\n    [\n        \"open\",\n        \"setRequestHeader\",\n        \"send\",\n        \"abort\",\n        \"getResponseHeader\",\n        \"getAllResponseHeaders\",\n        \"addEventListener\",\n        \"overrideMimeType\",\n        \"removeEventListener\"\n    ].forEach(function (method) {\n        fakeXhr[method] = function () {\n            return apply(xhr, method, arguments);\n        };\n    });\n\n    var copyAttrs = function (args) {\n        args.forEach(function (attr) {\n            fakeXhr[attr] = xhr[attr];\n        });\n    };\n\n    var stateChange = function stateChange() {\n        fakeXhr.readyState = xhr.readyState;\n        if (xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {\n            copyAttrs([\"status\", \"statusText\"]);\n        }\n        if (xhr.readyState >= FakeXMLHttpRequest.LOADING) {\n            copyAttrs([\"responseText\", \"response\"]);\n        }\n        if (xhr.readyState === FakeXMLHttpRequest.DONE) {\n            copyAttrs([\"responseXML\"]);\n        }\n        if (fakeXhr.onreadystatechange) {\n            fakeXhr.onreadystatechange.call(fakeXhr, { target: fakeXhr });\n        }\n    };\n\n    if (xhr.addEventListener) {\n        Object.keys(fakeXhr.eventListeners).forEach(function (event) {\n            /*eslint-disable no-loop-func*/\n            fakeXhr.eventListeners[event].forEach(function (handler) {\n                xhr.addEventListener(event, handler);\n            });\n            /*eslint-enable no-loop-func*/\n        });\n\n        xhr.addEventListener(\"readystatechange\", stateChange);\n    } else {\n        xhr.onreadystatechange = stateChange;\n    }\n    apply(xhr, \"open\", xhrArgs);\n};\nFakeXMLHttpRequest.useFilters = false;\n\nfunction verifyRequestOpened(xhr) {\n    if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n        throw new Error(\"INVALID_STATE_ERR - \" + xhr.readyState);\n    }\n}\n\nfunction verifyRequestSent(xhr) {\n    if (xhr.readyState === FakeXMLHttpRequest.DONE) {\n        throw new Error(\"Request done\");\n    }\n}\n\nfunction verifyHeadersReceived(xhr) {\n    if (xhr.async && xhr.readyState !== FakeXMLHttpRequest.HEADERS_RECEIVED) {\n        throw new Error(\"No headers received\");\n    }\n}\n\nfunction verifyResponseBodyType(body) {\n    if (typeof body !== \"string\") {\n        var error = new Error(\"Attempted to respond to fake XMLHttpRequest with \" +\n                             body + \", which is not a string.\");\n        error.name = \"InvalidBodyException\";\n        throw error;\n    }\n}\n\nfunction convertToArrayBuffer(body, encoding) {\n    return new TextEncoder(encoding || \"utf-8\").encode(body).buffer;\n}\n\nfunction isXmlContentType(contentType) {\n    return !contentType || /(text\\/xml)|(application\\/xml)|(\\+xml)/.test(contentType);\n}\n\nfunction convertResponseBody(responseType, contentType, body) {\n    if (responseType === \"\" || responseType === \"text\") {\n        return body;\n    } else if (supportsArrayBuffer && responseType === \"arraybuffer\") {\n        return convertToArrayBuffer(body);\n    } else if (responseType === \"json\") {\n        try {\n            return JSON.parse(body);\n        } catch (e) {\n            // Return parsing failure as null\n            return null;\n        }\n    } else if (supportsBlob && responseType === \"blob\") {\n        var blobOptions = {};\n        if (contentType) {\n            blobOptions.type = contentType;\n        }\n        return new Blob([convertToArrayBuffer(body)], blobOptions);\n    } else if (responseType === \"document\") {\n        if (isXmlContentType(contentType)) {\n            return FakeXMLHttpRequest.parseXML(body);\n        }\n        return null;\n    }\n    throw new Error(\"Invalid responseType \" + responseType);\n}\n\nfunction clearResponse(xhr) {\n    if (xhr.responseType === \"\" || xhr.responseType === \"text\") {\n        xhr.response = xhr.responseText = \"\";\n    } else {\n        xhr.response = xhr.responseText = null;\n    }\n    xhr.responseXML = null;\n}\n\nFakeXMLHttpRequest.parseXML = function parseXML(text) {\n    // Treat empty string as parsing failure\n    if (text !== \"\") {\n        try {\n            if (typeof DOMParser !== \"undefined\") {\n                var parser = new DOMParser();\n                return parser.parseFromString(text, \"text/xml\");\n            }\n            var xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = \"false\";\n            xmlDoc.loadXML(text);\n            return xmlDoc;\n        } catch (e) {\n            // Unable to parse XML - no biggie\n        }\n    }\n\n    return null;\n};\n\nFakeXMLHttpRequest.statusCodes = {\n    100: \"Continue\",\n    101: \"Switching Protocols\",\n    200: \"OK\",\n    201: \"Created\",\n    202: \"Accepted\",\n    203: \"Non-Authoritative Information\",\n    204: \"No Content\",\n    205: \"Reset Content\",\n    206: \"Partial Content\",\n    207: \"Multi-Status\",\n    300: \"Multiple Choice\",\n    301: \"Moved Permanently\",\n    302: \"Found\",\n    303: \"See Other\",\n    304: \"Not Modified\",\n    305: \"Use Proxy\",\n    307: \"Temporary Redirect\",\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    402: \"Payment Required\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    405: \"Method Not Allowed\",\n    406: \"Not Acceptable\",\n    407: \"Proxy Authentication Required\",\n    408: \"Request Timeout\",\n    409: \"Conflict\",\n    410: \"Gone\",\n    411: \"Length Required\",\n    412: \"Precondition Failed\",\n    413: \"Request Entity Too Large\",\n    414: \"Request-URI Too Long\",\n    415: \"Unsupported Media Type\",\n    416: \"Requested Range Not Satisfiable\",\n    417: \"Expectation Failed\",\n    422: \"Unprocessable Entity\",\n    500: \"Internal Server Error\",\n    501: \"Not Implemented\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    504: \"Gateway Timeout\",\n    505: \"HTTP Version Not Supported\"\n};\n\nextend(FakeXMLHttpRequest.prototype, sinonEvent.EventTarget, {\n    async: true,\n\n    open: function open(method, url, async, username, password) {\n        this.method = method;\n        this.url = url;\n        this.async = typeof async === \"boolean\" ? async : true;\n        this.username = username;\n        this.password = password;\n        clearResponse(this);\n        this.requestHeaders = {};\n        this.sendFlag = false;\n\n        if (FakeXMLHttpRequest.useFilters === true) {\n            var xhrArgs = arguments;\n            var defake = FakeXMLHttpRequest.filters.some(function (filter) {\n                return filter.apply(this, xhrArgs);\n            });\n            if (defake) {\n                FakeXMLHttpRequest.defake(this, arguments);\n                return;\n            }\n        }\n        this.readyStateChange(FakeXMLHttpRequest.OPENED);\n    },\n\n    readyStateChange: function readyStateChange(state) {\n        this.readyState = state;\n\n        var readyStateChangeEvent = new sinonEvent.Event(\"readystatechange\", false, false, this);\n        var event, progress;\n\n        if (typeof this.onreadystatechange === \"function\") {\n            try {\n                this.onreadystatechange(readyStateChangeEvent);\n            } catch (e) {\n                this.logError(\"Fake XHR onreadystatechange handler\", e);\n            }\n        }\n\n        if (this.readyState === FakeXMLHttpRequest.DONE) {\n            if (this.aborted || this.status === 0) {\n                progress = {loaded: 0, total: 0};\n                event = this.aborted ? \"abort\" : \"error\";\n            } else {\n                progress = {loaded: 100, total: 100};\n                event = \"load\";\n            }\n\n            if (supportsProgress) {\n                this.upload.dispatchEvent(new sinonEvent.ProgressEvent(\"progress\", progress, this));\n                this.upload.dispatchEvent(new sinonEvent.ProgressEvent(event, progress, this));\n                this.upload.dispatchEvent(new sinonEvent.ProgressEvent(\"loadend\", progress, this));\n            }\n\n            this.dispatchEvent(new sinonEvent.ProgressEvent(\"progress\", progress, this));\n            this.dispatchEvent(new sinonEvent.ProgressEvent(event, progress, this));\n            this.dispatchEvent(new sinonEvent.ProgressEvent(\"loadend\", progress, this));\n        }\n\n        this.dispatchEvent(readyStateChangeEvent);\n    },\n\n    setRequestHeader: function setRequestHeader(header, value) {\n        verifyState(this);\n\n        var checkUnsafeHeaders = true;\n        if (typeof this.unsafeHeadersEnabled === \"function\") {\n            checkUnsafeHeaders = this.unsafeHeadersEnabled();\n        }\n\n        if (checkUnsafeHeaders && (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header))) {\n            throw new Error(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n        }\n\n        if (this.requestHeaders[header]) {\n            this.requestHeaders[header] += \",\" + value;\n        } else {\n            this.requestHeaders[header] = value;\n        }\n    },\n\n    setStatus: function setStatus(status) {\n        var sanitizedStatus = typeof status === \"number\" ? status : 200;\n\n        verifyRequestOpened(this);\n        this.status = sanitizedStatus;\n        this.statusText = FakeXMLHttpRequest.statusCodes[sanitizedStatus];\n    },\n\n    // Helps testing\n    setResponseHeaders: function setResponseHeaders(headers) {\n        verifyRequestOpened(this);\n\n        var responseHeaders = this.responseHeaders = {};\n\n        Object.keys(headers).forEach(function (header) {\n            responseHeaders[header] = headers[header];\n        });\n\n        if (this.async) {\n            this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);\n        } else {\n            this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;\n        }\n    },\n\n    // Currently treats ALL data as a DOMString (i.e. no Document)\n    send: function send(data) {\n        verifyState(this);\n\n        if (!/^(head)$/i.test(this.method)) {\n            var contentType = getHeader(this.requestHeaders, \"Content-Type\");\n            if (this.requestHeaders[contentType]) {\n                var value = this.requestHeaders[contentType].split(\";\");\n                this.requestHeaders[contentType] = value[0] + \";charset=utf-8\";\n            } else if (supportsFormData && !(data instanceof FormData)) {\n                this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=utf-8\";\n            }\n\n            this.requestBody = data;\n        }\n\n        this.errorFlag = false;\n        this.sendFlag = this.async;\n        clearResponse(this);\n        this.readyStateChange(FakeXMLHttpRequest.OPENED);\n\n        if (typeof this.onSend === \"function\") {\n            this.onSend(this);\n        }\n\n        this.dispatchEvent(new sinonEvent.Event(\"loadstart\", false, false, this));\n    },\n\n    abort: function abort() {\n        this.aborted = true;\n        clearResponse(this);\n        this.errorFlag = true;\n        this.requestHeaders = {};\n        this.responseHeaders = {};\n\n        if (this.readyState !== FakeXMLHttpRequest.UNSENT && this.sendFlag\n            && this.readyState !== FakeXMLHttpRequest.DONE) {\n            this.readyStateChange(FakeXMLHttpRequest.DONE);\n            this.sendFlag = false;\n        }\n\n        this.readyState = FakeXMLHttpRequest.UNSENT;\n    },\n\n    error: function () {\n        clearResponse(this);\n        this.errorFlag = true;\n        this.requestHeaders = {};\n        this.responseHeaders = {};\n\n        this.readyStateChange(FakeXMLHttpRequest.DONE);\n    },\n\n    getResponseHeader: function getResponseHeader(header) {\n        if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n            return null;\n        }\n\n        if (/^Set-Cookie2?$/i.test(header)) {\n            return null;\n        }\n\n        header = getHeader(this.responseHeaders, header);\n\n        return this.responseHeaders[header] || null;\n    },\n\n    getAllResponseHeaders: function getAllResponseHeaders() {\n        if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n            return \"\";\n        }\n\n        var responseHeaders = this.responseHeaders;\n        var headers = Object.keys(responseHeaders)\n            .filter(excludeSetCookie2Header)\n            .reduce(function (prev, header) {\n                var value = responseHeaders[header];\n\n                return prev + (header + \": \" + value + \"\\r\\n\");\n            }, \"\");\n\n        return headers;\n    },\n\n    setResponseBody: function setResponseBody(body) {\n        verifyRequestSent(this);\n        verifyHeadersReceived(this);\n        verifyResponseBodyType(body);\n        var contentType = this.overriddenMimeType || this.getResponseHeader(\"Content-Type\");\n\n        var isTextResponse = this.responseType === \"\" || this.responseType === \"text\";\n        clearResponse(this);\n        if (this.async) {\n            var chunkSize = this.chunkSize || 10;\n            var index = 0;\n\n            do {\n                this.readyStateChange(FakeXMLHttpRequest.LOADING);\n\n                if (isTextResponse) {\n                    this.responseText = this.response += body.substring(index, index + chunkSize);\n                }\n                index += chunkSize;\n            } while (index < body.length);\n        }\n\n        this.response = convertResponseBody(this.responseType, contentType, body);\n        if (isTextResponse) {\n            this.responseText = this.response;\n        }\n\n        if (this.responseType === \"document\") {\n            this.responseXML = this.response;\n        } else if (this.responseType === \"\" && isXmlContentType(contentType)) {\n            this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);\n        }\n        this.readyStateChange(FakeXMLHttpRequest.DONE);\n    },\n\n    respond: function respond(status, headers, body) {\n        this.setStatus(status);\n        this.setResponseHeaders(headers || {});\n        this.setResponseBody(body || \"\");\n    },\n\n    uploadProgress: function uploadProgress(progressEventRaw) {\n        if (supportsProgress) {\n            this.upload.dispatchEvent(new sinonEvent.ProgressEvent(\"progress\", progressEventRaw));\n        }\n    },\n\n    downloadProgress: function downloadProgress(progressEventRaw) {\n        if (supportsProgress) {\n            this.dispatchEvent(new sinonEvent.ProgressEvent(\"progress\", progressEventRaw));\n        }\n    },\n\n    uploadError: function uploadError(error) {\n        if (supportsCustomEvent) {\n            this.upload.dispatchEvent(new sinonEvent.CustomEvent(\"error\", {detail: error}));\n        }\n    },\n\n    overrideMimeType: function overrideMimeType(type) {\n        if (this.readyState >= FakeXMLHttpRequest.LOADING) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n        this.overriddenMimeType = type;\n    }\n});\n\nvar states = {\n    UNSENT: 0,\n    OPENED: 1,\n    HEADERS_RECEIVED: 2,\n    LOADING: 3,\n    DONE: 4\n};\n\nextend(FakeXMLHttpRequest, states);\nextend(FakeXMLHttpRequest.prototype, states);\n\nfunction useFakeXMLHttpRequest() {\n    FakeXMLHttpRequest.restore = function restore(keepOnCreate) {\n        if (sinonXhr.supportsXHR) {\n            global.XMLHttpRequest = sinonXhr.GlobalXMLHttpRequest;\n        }\n\n        if (sinonXhr.supportsActiveX) {\n            global.ActiveXObject = sinonXhr.GlobalActiveXObject;\n        }\n\n        delete FakeXMLHttpRequest.restore;\n\n        if (keepOnCreate !== true) {\n            delete FakeXMLHttpRequest.onCreate;\n        }\n    };\n    if (sinonXhr.supportsXHR) {\n        global.XMLHttpRequest = FakeXMLHttpRequest;\n    }\n\n    if (sinonXhr.supportsActiveX) {\n        global.ActiveXObject = function ActiveXObject(objId) {\n            if (objId === \"Microsoft.XMLHTTP\" || /^Msxml2\\.XMLHTTP/i.test(objId)) {\n\n                return new FakeXMLHttpRequest();\n            }\n\n            return new sinonXhr.GlobalActiveXObject(objId);\n        };\n    }\n\n    return FakeXMLHttpRequest;\n}\n\nmodule.exports = {\n    xhr: sinonXhr,\n    FakeXMLHttpRequest: FakeXMLHttpRequest,\n    useFakeXMLHttpRequest: useFakeXMLHttpRequest\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/event.js":"\"use strict\";\n\nvar push = [].push;\n\nfunction Event(type, bubbles, cancelable, target) {\n    this.initEvent(type, bubbles, cancelable, target);\n}\n\nEvent.prototype = {\n    initEvent: function (type, bubbles, cancelable, target) {\n        this.type = type;\n        this.bubbles = bubbles;\n        this.cancelable = cancelable;\n        this.target = target;\n    },\n\n    stopPropagation: function () {},\n\n    preventDefault: function () {\n        this.defaultPrevented = true;\n    }\n};\n\nfunction ProgressEvent(type, progressEventRaw, target) {\n    this.initEvent(type, false, false, target);\n    this.loaded = typeof progressEventRaw.loaded === \"number\" ? progressEventRaw.loaded : null;\n    this.total = typeof progressEventRaw.total === \"number\" ? progressEventRaw.total : null;\n    this.lengthComputable = !!progressEventRaw.total;\n}\n\nProgressEvent.prototype = new Event();\n\nProgressEvent.prototype.constructor = ProgressEvent;\n\nfunction CustomEvent(type, customData, target) {\n    this.initEvent(type, false, false, target);\n    this.detail = customData.detail || null;\n}\n\nCustomEvent.prototype = new Event();\n\nCustomEvent.prototype.constructor = CustomEvent;\n\nvar EventTarget = {\n    addEventListener: function addEventListener(event, listener) {\n        this.eventListeners = this.eventListeners || {};\n        this.eventListeners[event] = this.eventListeners[event] || [];\n        push.call(this.eventListeners[event], listener);\n    },\n\n    removeEventListener: function removeEventListener(event, listener) {\n        var listeners = this.eventListeners && this.eventListeners[event] || [];\n        var index = listeners.indexOf(listener);\n\n        if (index === -1) {\n            return;\n        }\n\n        listeners.splice(index, 1);\n    },\n\n    dispatchEvent: function dispatchEvent(event) {\n        var self = this;\n        var type = event.type;\n        var listeners = self.eventListeners && self.eventListeners[type] || [];\n\n        listeners.forEach(function (listener) {\n            if (typeof listener === \"function\") {\n                listener.call(self, event);\n            } else {\n                listener.handleEvent(event);\n            }\n        });\n\n        return !!event.defaultPrevented;\n    }\n};\n\nmodule.exports = {\n    Event: Event,\n    ProgressEvent: ProgressEvent,\n    CustomEvent: CustomEvent,\n    EventTarget: EventTarget\n};\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/blob.js":"/*global Blob */\n\"use strict\";\n\nexports.isSupported = (function () {\n    try {\n        return !!new Blob();\n    } catch (e) {\n        return false;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sinon/sinon/lib/sinon/util/fake_server_with_clock.js":"\"use strict\";\n\nvar fakeServer = require(\"./fake_server\");\nvar fakeTimers = require(\"./fake_timers\");\n\nfunction Server() {}\nServer.prototype = fakeServer;\n\nvar fakeServerWithClock = new Server();\n\nfakeServerWithClock.addRequest = function addRequest(xhr) {\n    if (xhr.async) {\n        if (typeof setTimeout.clock === \"object\") {\n            this.clock = setTimeout.clock;\n        } else {\n            this.clock = fakeTimers.useFakeTimers();\n            this.resetClock = true;\n        }\n\n        if (!this.longestTimeout) {\n            var clockSetTimeout = this.clock.setTimeout;\n            var clockSetInterval = this.clock.setInterval;\n            var server = this;\n\n            this.clock.setTimeout = function (fn, timeout) {\n                server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n\n                return clockSetTimeout.apply(this, arguments);\n            };\n\n            this.clock.setInterval = function (fn, timeout) {\n                server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n\n                return clockSetInterval.apply(this, arguments);\n            };\n        }\n    }\n\n    return fakeServer.addRequest.call(this, xhr);\n};\n\nfakeServerWithClock.respond = function respond() {\n    var returnVal = fakeServer.respond.apply(this, arguments);\n\n    if (this.clock) {\n        this.clock.tick(this.longestTimeout || 0);\n        this.longestTimeout = 0;\n\n        if (this.resetClock) {\n            this.clock.restore();\n            this.resetClock = false;\n        }\n    }\n\n    return returnVal;\n};\n\nfakeServerWithClock.restore = function restore() {\n    if (this.clock) {\n        this.clock.restore();\n    }\n\n    return fakeServer.restore.apply(this, arguments);\n};\n\nmodule.exports = fakeServerWithClock;\n"}